<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#1e3a8a" />
  <meta name="description" content="é¡¹ç›®ç®¡ç†ä¹‹èˆŸ - ä¸“ä¸ºå°å±è®¾å¤‡ä¼˜åŒ–çš„é¡¹ç›®ç®¡ç†å¯è§†åŒ–å·¥å…·" />
  <title>é¡¹ç›®ç®¡ç†ä¹‹èˆŸ</title>

  <!-- PWA Manifest (å†…è”) -->
  <link rel="manifest" href="data:application/manifest+json;base64,ewogICJuYW1lIjogIueVmeaKpeWtpuivvyIsCiAgInNob3J0X25hbWUiOiAi55WZ5oql5a2m6K%2F%2FIiwKICAic3RhcnRfdXJsIjogIi4vIiwKICAiZGlzcGxheSI6ICJzdGFuZGFsb25lIiwKICAiYmFja2dyb3VuZF9jb2xvciI6ICIjMWUzYThhIiwKICAidGhlbWVfY29sb3IiOiAiIzFlM2E4YSIsCiAgImljb25zIjogWwogICAgewogICAgICAic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIj48cGF0aCBmaWxsPSIjMWUzYThhIiBkPSJNMCAwaDE5MnYxOTJIMHoiLz48dGV4dCB4PSI5NiIgeT0iOTYiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSI0MCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiPuWVmeaKpeWtpuivvyAgPC90ZXh0Pjwvc3ZnPg==IiwKICAgICAgInNpemVzIjogIjE5MngxOTIiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIgogICAgfQogIF0KfQo=">

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'PingFang SC', 'Microsoft YaHei', sans-serif;
      background: linear-gradient(135deg, #0f172a, #1e3a8a);
      color: white;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      position: relative;
    }

    .orientation-alert {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      text-align: center;
      padding: 20px;
    }

    .orientation-alert h2 {
      font-size: 2rem;
      margin-bottom: 15px;
      color: #60a5fa;
    }

    .orientation-alert p {
      font-size: 1.2rem;
      color: #cbd5e1;
      max-width: 90%;
    }

    .container {
      position: relative;
      width: 100%;
      height: 100%;
      display: none;
      overflow: hidden;
    }

    .card {
      position: absolute;
      width: 110px;
      height: 95px;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 6px;
      text-align: center;
      cursor: grab;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
      border: 2px solid #60a5fa;
      transition: transform 0.2s, box-shadow 0.2s;
      z-index: 10;
      backface-visibility: hidden;
      will-change: transform;
    }

    .card.dragging {
      transform: scale(1.05);
      z-index: 20;
      box-shadow: 0 0 0 3px #fbbf24, 0 0 15px rgba(251, 191, 36, 0.6);
    }

    .card:active {
      cursor: grabbing;
    }

    .card-title {
      font-weight: bold;
      font-size: 0.95rem;
      line-height: 1.3;
      margin-bottom: 2px;
    }

    .card-sub {
      font-size: 0.75rem;
      line-height: 1.3;
    }

    .card-edge {
      position: absolute;
      background: rgba(255, 255, 255, 0.2);
      z-index: 12;
      pointer-events: auto;
      transition: background 0.2s;
    }
    
    .card-top { top: 0; left: 0; width: 100%; height: 15px; border-top-left-radius: 10px; border-top-right-radius: 10px; }
    .card-right { top: 0; right: 0; width: 15px; height: 100%; border-top-right-radius: 10px; border-bottom-right-radius: 10px; }
    .card-bottom { bottom: 0; left: 0; width: 100%; height: 15px; border-bottom-left-radius: 10px; border-bottom-right-radius: 10px; }
    .card-left { top: 0; left: 0; width: 15px; height: 100%; border-top-left-radius: 10px; border-bottom-left-radius: 10px; }

    .card-edge:hover {
      background: rgba(96, 165, 250, 0.4);
    }

    .card.highlight {
      box-shadow: 0 0 0 3px #fbbf24, 0 0 15px rgba(251, 191, 36, 0.6);
    }

    .card.source-card {
      box-shadow: 0 0 0 3px #10b981, 0 0 15px rgba(16, 185, 129, 0.7);
    }

    .toolbar {
      position: absolute;
      bottom: 15px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      gap: 15px;
      z-index: 100;
      padding: 0 10px;
    }

    .btn {
      padding: 10px 18px;
      border-radius: 25px;
      border: none;
      font-weight: bold;
      font-size: 0.95rem;
      cursor: pointer;
      background: rgba(30, 58, 138, 0.92);
      color: white;
      border: 2px solid #60a5fa;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.35);
      min-width: 100px;
      touch-action: manipulation;
      transition: all 0.2s;
    }

    .btn:active {
      transform: scale(0.97);
    }

    .btn:hover {
      background: rgba(59, 130, 246, 0.95);
    }

    .btn.delete-mode {
      background: rgba(185, 28, 28, 0.95);
      border-color: #f87171;
    }

    .btn.connect-mode {
      background: rgba(16, 185, 129, 0.95);
      border-color: #10b981;
    }

    .color-picker {
      position: absolute;
      background: rgba(15, 23, 42, 0.95);
      border: 2px solid #60a5fa;
      border-radius: 12px;
      padding: 12px 8px;
      display: none;
      z-index: 50;
      box-shadow: 0 5px 18px rgba(0, 0, 0, 0.5);
      min-width: 220px;
    }

    .color-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
    }

    .color-item {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid #60a5fa;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .color-item:hover, .color-item.selected {
      transform: scale(1.2);
      box-shadow: 0 0 0 3px white;
    }

    .connections-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }

    .temp-connection {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 7;
    }

    .connection-path {
      pointer-events: auto !important;
      cursor: pointer;
    }

    .connection-label {
      position: absolute;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid #60a5fa;
      border-radius: 14px;
      padding: 4px 10px;
      font-size: 0.8rem;
      transform: translate(-50%, -50%);
      pointer-events: auto;
      cursor: pointer;
      max-width: 120px;
      text-align: center;
      word-break: break-word;
      z-index: 6;
      touch-action: manipulation;
    }

    .connection-type-bar {
      position: absolute;
      background: rgba(15, 23, 42, 0.95);
      border: 2px solid #60a5fa;
      border-radius: 30px;
      padding: 8px;
      display: none;
      z-index: 50;
      box-shadow: 0 5px 18px rgba(0, 0, 0, 0.5);
      min-width: 240px;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
    }

    .type-selector {
      display: flex;
      justify-content: space-around;
      align-items: center;
    }

    .line-type {
      width: 30px;
      height: 2px;
      background: #60a5fa;
      position: relative;
      cursor: pointer;
      margin: 0 5px;
    }

    .line-type:hover {
      background: #fbbf24;
    }

    .line-type.straight { width: 30px; }
    .line-type.polyline { width: 30px; height: 3px; background: none; }
    .line-type.polyline:after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 15px;
      height: 2px;
      background: #60a5fa;
    }
    .line-type.polyline:before {
      content: '';
      position: absolute;
      top: 0;
      left: 15px;
      width: 15px;
      height: 2px;
      background: #60a5fa;
      transform: translateY(8px);
    }

    .arrow-type {
      position: relative;
      width: 12px;
      height: 12px;
      margin: 0 4px;
      cursor: pointer;
    }

    .arrow-type.none:before { content: ''; }
    .arrow-type.single:after {
      content: '';
      position: absolute;
      top: 4px;
      left: 0;
      width: 0;
      height: 0;
      border-top: 4px solid transparent;
      border-bottom: 4px solid transparent;
      border-left: 6px solid #60a5fa;
    }
    .arrow-type.double:before,
    .arrow-type.double:after {
      content: '';
      position: absolute;
      top: 4px;
      width: 0;
      height: 0;
      border-top: 4px solid transparent;
      border-bottom: 4px solid transparent;
    }
    .arrow-type.double:before {
      right: 0;
      border-left: 6px solid #60a5fa;
    }
    .arrow-type.double:after {
      left: 0;
      border-right: 6px solid #60a5fa;
    }

    .arrow-type:hover .arrow-type:after,
    .arrow-type:hover .arrow-type:before {
      border-left-color: #fbbf24;
      border-right-color: #fbbf24;
    }

    .type-label {
      font-size: 0.75rem;
      color: #94a3b8;
      margin-top: 4px;
    }

    .export-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.92);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 200;
      touch-action: none;
    }

    .modal-content {
      background: rgba(15, 23, 42, 0.97);
      border: 2px solid #60a5fa;
      border-radius: 18px;
      padding: 25px;
      width: 90%;
      max-width: 380px;
      text-align: center;
    }

    .modal-title {
      font-size: 1.4rem;
      margin-bottom: 15px;
      color: #60a5fa;
    }

    .export-options {
      display: flex;
      gap: 15px;
      margin: 15px 0;
      flex-wrap: wrap;
      justify-content: center;
    }

    .export-option {
      background: rgba(30, 58, 138, 0.8);
      border: 1px solid #60a5fa;
      border-radius: 12px;
      padding: 12px;
      width: 140px;
      cursor: pointer;
      transition: all 0.2s;
      touch-action: manipulation;
    }

    .export-option:hover, .export-option:active {
      background: rgba(59, 130, 246, 0.85);
      transform: translateY(-2px);
    }

    .loading {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.88);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 300;
      touch-action: none;
    }

    .spinner {
      width: 35px;
      height: 35px;
      border: 3px solid rgba(96, 165, 250, 0.3);
      border-top: 3px solid #60a5fa;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 12px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-text {
      font-size: 1.1rem;
      text-align: center;
      padding: 0 20px;
    }

    .status-bar-padding {
      height: env(safe-area-inset-top);
    }

    .watermark {
      position: absolute;
      bottom: 8px;
      right: 10px;
      font-size: 0.75rem;
      color: rgba(156, 163, 175, 0.8);
      z-index: 1;
    }

    .instructions {
      position: absolute;
      top: 12px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 0.95rem;
      color: #94a3b8;
      z-index: 100;
      padding: 0 20px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }

    .highlight-instruction {
      color: #fbbf24;
      font-weight: bold;
    }

    @media (max-aspect-ratio: 13/9) {
      .orientation-alert {
        display: flex;
      }
    }

    /* ç¡®ä¿åœ¨ iOS å®‰å…¨åŒºåŸŸå†… */
    @supports (padding-top: env(safe-area-inset-top)) {
      body {
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
      }
      
      .toolbar {
        bottom: calc(15px + env(safe-area-inset-bottom));
      }
      
      .connection-type-bar {
        bottom: calc(70px + env(safe-area-inset-bottom));
      }
    }
  </style>
</head>
<body>
  <div class="orientation-alert">
    <h2>ğŸ“± è¯·æ¨ªå±ä½¿ç”¨</h2>
    <p>ä¸ºäº†è·å¾—æœ€ä½³ä½“éªŒï¼Œè¯·å°†æ‰‹æœºæ—‹è½¬è‡³æ¨ªå±æ¨¡å¼</p>
  </div>

  <div class="container" id="container">
    <div class="connections-container" id="connectionsContainer"></div>
    <!-- Cards will be inserted by JS -->
    
    <div class="temp-connection" id="tempConnection"></div>

    <div class="toolbar">
      <button class="btn" id="connectBtn">åˆ›å»ºè¿çº¿</button>
      <button class="btn" id="deleteBtn">åˆ é™¤è¿çº¿</button>
      <button class="btn" id="exportBtn">å¯¼å‡ºç»“æœ</button>
    </div>

    <div class="color-picker" id="colorPicker">
      <div class="color-grid" id="colorGrid"></div>
    </div>

    <div class="connection-type-bar" id="typeBar">
      <div class="type-selector">
        <div class="line-type straight" data-type="straight" title="ç›´çº¿è¿æ¥"></div>
        <div class="line-type polyline" data-type="polyline" title="æŠ˜çº¿è¿æ¥"></div>
        <div style="flex:1"></div>
        <div class="arrow-type none" data-type="none" title="æ— ç®­å¤´"></div>
        <div class="arrow-type single" data-type="single" title="å•å‘ç®­å¤´"></div>
        <div class="arrow-type double" data-type="double" title="åŒå‘ç®­å¤´"></div>
        <div style="flex:1"></div>
        <div style="text-align: center; margin-left: 10px;">
          <div style="font-weight: bold; color: #fbbf24;">ç¡®è®¤</div>
          <div class="type-label">ç‚¹å‡»å¡ç‰‡å®Œæˆ</div>
        </div>
      </div>
    </div>

    <div class="instructions" id="instructions">
      <span class="highlight-instruction">æ‹–æ‹½</span>å¡ç‰‡è°ƒæ•´ä½ç½® â€¢ 
      <span class="highlight-instruction">ç‚¹å‡»</span>å¡ç‰‡ä¿®æ”¹é¢œè‰² â€¢ 
      <span class="highlight-instruction">ç‚¹å‡»åº•éƒ¨æŒ‰é’®</span>åˆ›å»º/åˆ é™¤è¿çº¿
    </div>

    <div class="watermark">é¡¹ç›®ç®¡ç†ä¹‹èˆŸ v1.3</div>
  </div>

  <div class="export-modal" id="exportModal">
    <div class="modal-content">
      <div class="modal-title">å¯¼å‡ºé¡¹ç›®ç®¡ç†æ–¹æ¡ˆ</div>
      <p>è¯·é€‰æ‹©ä¿å­˜æ ¼å¼</p>
      <div class="export-options">
        <div class="export-option" id="exportJpg">
          <svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z" fill="#60a5fa"/>
          </svg>
          <div style="margin-top: 8px; font-weight: bold;">JPG å›¾ç‰‡</div>
        </div>
        <div class="export-option" id="exportXml">
          <svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z" fill="#60a5fa"/>
          </svg>
          <div style="margin-top: 8px; font-weight: bold;">XML æ•°æ®</div>
        </div>
      </div>
      <p style="font-size: 0.8rem; color: #94a3b8; margin-top: 12px;">
        æ–‡ä»¶å°†è‡ªåŠ¨ä¸‹è½½åˆ°æ‚¨çš„è®¾å¤‡
      </p>
    </div>
  </div>

  <div class="loading" id="loading">
    <div class="spinner"></div>
    <div class="loading-text">æ­£åœ¨ç”Ÿæˆå¯¼å‡ºæ–‡ä»¶<br>è¯·ç¨å€™...</div>
  </div>

  <!-- html2canvas for JPG export -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <script>
    // Card data
    const cards = [
      { title: "èŠ±å¤šé•¿æ—¶é—´åšï¼Ÿ", sub: "è¿›åº¦ç®¡ç†" },
      { title: "å¦‚ä½•å®ç°æ•´ä½“æœ€ä¼˜ï¼Ÿ", sub: "æ•´åˆç®¡ç†" },
      { title: "å¦‚ä½•æ‰æ»¡æ„ï¼Ÿ", sub: "ä»·å€¼ç®¡ç†" },
      { title: "è°æ¥åšï¼Ÿ", sub: "èµ„æºä¸é‡‡è´­ç®¡ç†" },
      { title: "æŒ‰ä»€ä¹ˆè´¨é‡åšï¼Ÿ", sub: "è´¨é‡ç®¡ç†" },
      { title: "åšä»€ä¹ˆï¼Ÿ", sub: "èŒƒå›´ç®¡ç†" },
      { title: "ä¸ºè°åšï¼Ÿ", sub: "å¹²ç³»äººç®¡ç†" },
      { title: "å¦‚ä½•åä½œï¼Ÿ", sub: "æ²Ÿé€šç®¡ç†" },
      { title: "ç”¨å¤šå°‘æˆæœ¬åšï¼Ÿ", sub: "æˆæœ¬ç®¡ç†" },
      { title: "æœ‰å“ªäº›äºº/è´¢/äº‹ä¼šå¢åŠ éš¾åº¦ï¼Ÿ", sub: "é£é™©ç®¡ç†" }
    ];

    // 6ç§æ˜¾è‘—åŒºåˆ†çš„é¢œè‰²
    const colors = [
      "#1e3a8a", // æ·±è“
      "#0d9488", // é’ç»¿
      "#c2410c", // æ©™çº¢
      "#7e22ce", // ç´«
      "#0ea5e9", // å¤©è“
      "#ca8a04"  // é‡‘é»„
    ];

    // State
    let state = {
      cards: [],
      connections: [],
      selectedCard: null,
      connectingCard: null,
      deleteMode: false,
      connectMode: false,
      lineType: 'straight', // 'straight' or 'polyline'
      arrowType: 'single',  // 'none', 'single', 'double'
      isDragging: false,
      dragOffset: { x: 0, y: 0 },
      tempConnection: null,
      anchorStart: null, // 'top' | 'right' | 'bottom' | 'left'
      anchorEnd: null,
      lastColorSelection: {}
    };

    const container = document.getElementById('container');
    const connectionsContainer = document.getElementById('connectionsContainer');
    const tempConnectionContainer = document.getElementById('tempConnection');
    const colorPicker = document.getElementById('colorPicker');
    const colorGrid = document.getElementById('colorGrid');
    const typeBar = document.getElementById('typeBar');
    const instructions = document.getElementById('instructions');

    // Init
    function init() {
      createCards();
      createColorPicker();
      setupTypeBar();
      setupEventListeners();
      checkOrientation();
      initWatermark();
      
      // æ·»åŠ è§¦æ‘¸åé¦ˆ
      document.body.addEventListener('touchstart', () => {}, { passive: true });
    }

    function createCards() {
      const w = container.clientWidth;
      const h = container.clientHeight;
      
      // iPhone 13 mini æ¨ªå±çº¦ 643x320pxï¼Œä¸º10ä¸ªå¡ç‰‡è§„åˆ’ä½ç½®
      const positions = [
        { x: 40, y: 40 },     { x: 180, y: 40 },    { x: 320, y: 40 },    { x: 460, y: 40 },    { x: 600, y: 40 },
        { x: 40, y: 180 },    { x: 180, y: 180 },   { x: 320, y: 180 },   { x: 460, y: 180 },   { x: 600, y: 180 }
      ];
      
      // ç¡®ä¿ä½ç½®åœ¨å±å¹•å†…
      const cardW = 110, cardH = 95;
      const padding = 15;
      
      cards.forEach((cardData, i) => {
        const card = document.createElement('div');
        card.className = 'card';
        card.dataset.id = `card-${i}`;
        
        // ä¸ºæ¯å¼ å¡ç‰‡åˆ†é…åˆå§‹é¢œè‰²ï¼ˆå¾ªç¯ä½¿ç”¨6ç§é¢œè‰²ï¼‰
        const color = colors[i % colors.length];
        card.style.backgroundColor = color;
        
        // è®¡ç®—æ–‡å­—é¢œè‰²
        const textColor = getContrastTextColor(color);
        card.style.color = textColor;
        
        // åˆ›å»ºè¾¹ç¼˜å¯ç‚¹å‡»åŒºåŸŸ
        ['top', 'right', 'bottom', 'left'].forEach(side => {
          const edge = document.createElement('div');
          edge.className = `card-edge card-${side}`;
          edge.dataset.side = side;
          card.appendChild(edge);
        });
        
        const title = document.createElement('div');
        title.className = 'card-title';
        title.innerText = cardData.title;
        title.style.color = textColor;
        
        const sub = document.createElement('div');
        sub.className = 'card-sub';
        sub.innerText = cardData.sub;
        sub.style.color = textColor;
        
        card.appendChild(title);
        card.appendChild(sub);
        
        // ä¸ºå‰6å¼ å¡ç‰‡åˆ†é…é¢„è®¾ä½ç½®ï¼Œå…¶ä½™éšæœº
        let x, y;
        if (i < positions.length) {
          x = positions[i].x;
          y = positions[i].y;
          
          // ç¡®ä¿å¡ç‰‡å®Œå…¨åœ¨å±å¹•å†…
          x = Math.max(padding, Math.min(w - cardW - padding, x));
          y = Math.max(padding, Math.min(h - cardH - padding, y));
        } else {
          x = padding + Math.random() * (w - 2 * padding - cardW);
          y = padding + Math.random() * (h - 2 * padding - cardH);
        }
        
        card.style.left = `${x}px`;
        card.style.top = `${y}px`;
        
        container.appendChild(card);
        
        state.cards.push({
          id: `card-${i}`,
          el: card,
          x: x,
          y: y,
          color: color,
          textColor: textColor,
          width: cardW,
          height: cardH
        });
        
        makeDraggable(card);
        setupCardEdges(card);
      });
    }

    function getContrastTextColor(bgColor) {
      // å°†åå…­è¿›åˆ¶é¢œè‰²è½¬æ¢ä¸º RGB
      let r, g, b;
      if (bgColor.startsWith('#')) {
        const hex = bgColor.slice(1);
        if (hex.length === 3) {
          r = parseInt(hex[0] + hex[0], 16);
          g = parseInt(hex[1] + hex[1], 16);
          b = parseInt(hex[2] + hex[2], 16);
        } else {
          r = parseInt(hex.substring(0, 2), 16);
          g = parseInt(hex.substring(2, 4), 16);
          b = parseInt(hex.substring(4, 6), 16);
        }
      } else {
        // ç®€å•å¤„ç†ï¼Œå®é™…åº”ç”¨ä¸­åº”æ›´å®Œå–„
        return '#ffffff';
      }
      
      // è®¡ç®—äº®åº¦
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      
      // äº®åº¦é˜ˆå€¼ï¼Œ128ä¸ºä¸­é—´å€¼
      return brightness < 160 ? '#ffffff' : '#000000';
    }

    function createColorPicker() {
      colorGrid.innerHTML = '';
      
      colors.forEach((color, index) => {
        const item = document.createElement('div');
        item.className = 'color-item';
        item.style.backgroundColor = color;
        
        // è®¾ç½®è¾¹æ¡†é¢œè‰²ä¸ºå¯¹æ¯”è‰²
        const borderColor = getContrastTextColor(color);
        item.style.borderColor = borderColor;
        
        item.addEventListener('click', () => {
          if (state.selectedCard) {
            // æ›´æ–°å¡ç‰‡èƒŒæ™¯è‰²
            state.selectedCard.el.style.backgroundColor = color;
            state.selectedCard.color = color;
            
            // æ›´æ–°æ–‡å­—é¢œè‰²
            const newTextColor = getContrastTextColor(color);
            state.selectedCard.textColor = newTextColor;
            
            // æ›´æ–°å­å…ƒç´ é¢œè‰²
            const title = state.selectedCard.el.querySelector('.card-title');
            const sub = state.selectedCard.el.querySelector('.card-sub');
            if (title) title.style.color = newTextColor;
            if (sub) sub.style.color = newTextColor;
            
            // æ›´æ–°çŠ¶æ€
            state.lastColorSelection[state.selectedCard.id] = index;
            
            hideColorPicker();
          }
        });
        
        colorGrid.appendChild(item);
      });
    }

    function setupTypeBar() {
      // è®¾ç½®çº¿æ¡ç±»å‹
      const lineTypes = typeBar.querySelectorAll('.line-type');
      lineTypes.forEach(el => {
        el.addEventListener('click', () => {
          state.lineType = el.dataset.type;
          
          // æ›´æ–°é«˜äº®
          lineTypes.forEach(l => l.style.background = l.dataset.type === state.lineType ? '#fbbf24' : '#60a5fa');
          
          updateTempConnection();
        });
      });
      
      // è®¾ç½®ç®­å¤´ç±»å‹
      const arrowTypes = typeBar.querySelectorAll('.arrow-type');
      arrowTypes.forEach(el => {
        el.addEventListener('click', () => {
          state.arrowType = el.dataset.type;
          
          // æ›´æ–°é«˜äº®
          arrowTypes.forEach(a => {
            if (a.dataset.type === state.arrowType) {
              a.style.borderColor = '#fbbf24';
              if (a.classList.contains('single')) a.style.borderLeftColor = '#fbbf24';
              if (a.classList.contains('double')) {
                a.style.borderLeftColor = '#fbbf24';
                a.style.borderRightColor = '#fbbf24';
              }
            } else {
              a.style.borderColor = '#60a5fa';
              if (a.classList.contains('single')) a.style.borderLeftColor = '#60a5fa';
              if (a.classList.contains('double')) {
                a.style.borderLeftColor = '#60a5fa';
                a.style.borderRightColor = '#60a5fa';
              }
            }
          });
          
          updateTempConnection();
        });
      });
      
      // åˆå§‹åŒ–é€‰ä¸­çŠ¶æ€
      document.querySelector('.line-type.straight').style.background = '#fbbf24';
      document.querySelector('.arrow-type.single').style.borderLeftColor = '#fbbf24';
      document.querySelector('.arrow-type.single').style.borderColor = '#fbbf24';
    }

    function makeDraggable(card) {
      let isDragging = false;
      let startX, startY, initialX, initialY;
      
      card.addEventListener('pointerdown', (e) => {
        if (state.deleteMode || state.connectMode) return;
        e.preventDefault();
        
        const rect = card.getBoundingClientRect();
        startX = e.clientX;
        startY = e.clientY;
        initialX = parseFloat(card.style.left);
        initialY = parseFloat(card.style.top);
        
        isDragging = true;
        state.isDragging = true;
        
        // é«˜äº®é€‰ä¸­
        state.cards.forEach(c => c.el.classList.remove('dragging'));
        card.classList.add('dragging');
        state.selectedCard = state.cards.find(c => c.el === card);
        
        // æ˜¾ç¤ºé¢œè‰²é€‰æ‹©å™¨
        showColorPicker(card);
      });
      
      window.addEventListener('pointermove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        
        const newX = initialX + dx;
        const newY = initialY + dy;
        
        const bounds = container.getBoundingClientRect();
        const cardW = 110, cardH = 95;
        const padding = 10;
        
        // é™åˆ¶åœ¨å®¹å™¨å†…
        const boundedX = Math.max(padding, Math.min(bounds.width - cardW - padding, newX));
        const boundedY = Math.max(padding, Math.min(bounds.height - cardH - padding, newY));
        
        card.style.left = `${boundedX}px`;
        card.style.top = `${boundedY}px`;
        
        // æ›´æ–°çŠ¶æ€
        const cardState = state.cards.find(c => c.el === card);
        if (cardState) {
          cardState.x = boundedX;
          cardState.y = boundedY;
        }
        
        redrawConnections();
        
        // æ›´æ–°ä¸´æ—¶è¿çº¿
        if (state.connectingCard) {
          updateTempConnection();
        }
      });
      
      const stopDrag = () => {
        if (!isDragging) return;
        
        isDragging = false;
        state.isDragging = false;
        card.classList.remove('dragging');
      };
      
      window.addEventListener('pointerup', stopDrag);
      window.addEventListener('pointerleave', stopDrag);
    }

    function setupCardEdges(card) {
      const edges = card.querySelectorAll('.card-edge');
      edges.forEach(edge => {
        edge.addEventListener('pointerdown', (e) => {
          e.stopPropagation();
          
          if (state.deleteMode) return;
          
          const side = edge.dataset.side;
          
          if (state.connectMode) {
            if (!state.connectingCard) {
              // ç¬¬ä¸€ä¸ªå¡ç‰‡è¢«é€‰ä¸­
              state.connectingCard = state.cards.find(c => c.el === card);
              state.anchorStart = side;
              
              card.classList.add('source-card');
              
              // æ˜¾ç¤ºç±»å‹é€‰æ‹©æ 
              typeBar.style.display = 'block';
              
              // æ›´æ–°æç¤º
              instructions.innerHTML = `
                <span class="highlight-instruction">é€‰æ‹©è¿æ¥ç±»å‹</span>ï¼Œç„¶å
                <span class="highlight-instruction">ç‚¹å‡»ç›®æ ‡å¡ç‰‡è¾¹ç¼˜</span>å®Œæˆè¿çº¿
              `;
              
              updateTempConnection(true);
            } else {
              // ç¬¬äºŒä¸ªå¡ç‰‡è¢«é€‰ä¸­ï¼Œå®Œæˆè¿çº¿
              const targetCard = state.cards.find(c => c.el === card);
              
              if (state.connectingCard.id !== targetCard.id) {
                // åˆ›å»ºè¿æ¥
                createConnection(
                  state.connectingCard, 
                  targetCard, 
                  state.anchorStart, 
                  side, 
                  state.lineType, 
                  state.arrowType
                );
              }
              
              // é‡ç½®çŠ¶æ€
              state.connectingCard.el.classList.remove('source-card');
              state.connectingCard = null;
              state.anchorStart = null;
              state.connectMode = false;
              
              // éšè—UI
              typeBar.style.display = 'none';
              tempConnectionContainer.innerHTML = '';
              
              // æ›´æ–°æŒ‰é’®çŠ¶æ€
              document.getElementById('connectBtn').classList.remove('connect-mode');
              document.getElementById('connectBtn').textContent = 'åˆ›å»ºè¿çº¿';
              
              // æ¢å¤æç¤º
              instructions.innerHTML = `
                <span class="highlight-instruction">æ‹–æ‹½</span>å¡ç‰‡è°ƒæ•´ä½ç½® â€¢ 
                <span class="highlight-instruction">ç‚¹å‡»</span>å¡ç‰‡ä¿®æ”¹é¢œè‰² â€¢ 
                <span class="highlight-instruction">ç‚¹å‡»åº•éƒ¨æŒ‰é’®</span>åˆ›å»º/åˆ é™¤è¿çº¿
              `;
            }
          }
        });
      });
    }

    function startConnectMode() {
      state.connectMode = true;
      document.getElementById('connectBtn').classList.add('connect-mode');
      document.getElementById('connectBtn').textContent = 'é€‰æ‹©æºå¡ç‰‡è¾¹ç¼˜';
      
      // é«˜äº®æ‰€æœ‰å¡ç‰‡è¾¹ç¼˜
      state.cards.forEach(card => {
        const edges = card.el.querySelectorAll('.card-edge');
        edges.forEach(edge => {
          edge.style.background = 'rgba(16, 185, 129, 0.3)';
          edge.style.border = '1px solid #10b981';
        });
      });
      
      instructions.innerHTML = `
        <span class="highlight-instruction">ç‚¹å‡»æºå¡ç‰‡è¾¹ç¼˜</span>å¼€å§‹åˆ›å»ºè¿çº¿
      `;
    }

    function cancelConnectMode() {
      state.connectMode = false;
      state.connectingCard = null;
      state.anchorStart = null;
      
      document.getElementById('connectBtn').classList.remove('connect-mode');
      document.getElementById('connectBtn').textContent = 'åˆ›å»ºè¿çº¿';
      
      // æ¢å¤å¡ç‰‡è¾¹ç¼˜æ ·å¼
      state.cards.forEach(card => {
        const edges = card.el.querySelectorAll('.card-edge');
        edges.forEach(edge => {
          edge.style.background = 'rgba(255, 255, 255, 0.2)';
          edge.style.border = 'none';
        });
      });
      
      // ç§»é™¤ä¸´æ—¶è¿çº¿
      tempConnectionContainer.innerHTML = '';
      typeBar.style.display = 'none';
      
      // æ¢å¤æç¤º
      instructions.innerHTML = `
        <span class="highlight-instruction">æ‹–æ‹½</span>å¡ç‰‡è°ƒæ•´ä½ç½® â€¢ 
        <span class="highlight-instruction">ç‚¹å‡»</span>å¡ç‰‡ä¿®æ”¹é¢œè‰² â€¢ 
        <span class="highlight-instruction">ç‚¹å‡»åº•éƒ¨æŒ‰é’®</span>åˆ›å»º/åˆ é™¤è¿çº¿
      `;
    }

    function updateTempConnection(isStarting = false) {
      if (!state.connectingCard || !state.anchorStart) return;
      
      const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      tempSvg.setAttribute('width', '100%');
      tempSvg.setAttribute('height', '100%');
      
      const tempPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      tempPath.setAttribute('stroke', '#fbbf24');
      tempPath.setAttribute('stroke-width', '3');
      tempPath.setAttribute('stroke-dasharray', '5,5');
      tempPath.setAttribute('fill', 'none');
      
      // æ·»åŠ ä¸´æ—¶ç®­å¤´
      if (state.arrowType !== 'none') {
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        marker.setAttribute('id', 'temp-arrow');
        marker.setAttribute('viewBox', '0 0 10 10');
        marker.setAttribute('refX', state.arrowType === 'single' ? '9' : '1');
        marker.setAttribute('refY', '5');
        marker.setAttribute('markerWidth', '6');
        marker.setAttribute('markerHeight', '6');
        marker.setAttribute('orient', 'auto');
        
        const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        poly.setAttribute('points', '0 0, 10 5, 0 10');
        poly.setAttribute('fill', '#fbbf24');
        
        marker.appendChild(poly);
        defs.appendChild(marker);
        tempSvg.appendChild(defs);
        
        if (state.arrowType === 'single') {
          tempPath.setAttribute('marker-end', 'url(#temp-arrow)');
        } else if (state.arrowType === 'double') {
          tempPath.setAttribute('marker-end', 'url(#temp-arrow)');
          
          const startMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
          startMarker.setAttribute('id', 'temp-arrow-start');
          startMarker.setAttribute('viewBox', '0 0 10 10');
          startMarker.setAttribute('refX', '1');
          startMarker.setAttribute('refY', '5');
          startMarker.setAttribute('markerWidth', '6');
          startMarker.setAttribute('markerHeight', '6');
          startMarker.setAttribute('orient', 'auto');
          
          const polyStart = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
          polyStart.setAttribute('points', '10 0, 0 5, 10 10');
          polyStart.setAttribute('fill', '#fbbf24');
          
          startMarker.appendChild(polyStart);
          defs.appendChild(startMarker);
          tempPath.setAttribute('marker-start', 'url(#temp-arrow-start)');
        }
      }
      
      tempSvg.appendChild(tempPath);
      tempConnectionContainer.innerHTML = '';
      tempConnectionContainer.appendChild(tempSvg);
      
      if (!isStarting) {
        // è·å–é¼ æ ‡ä½ç½®
        const mouseX = state.lastMouseX || (container.clientWidth / 2);
        const mouseY = state.lastMouseY || (container.clientHeight / 2);
        
        // è®¡ç®—èµ·ç‚¹
        const p1 = getAnchorPoint(state.connectingCard, state.anchorStart);
        
        // åˆ›å»ºä¸´æ—¶ç»ˆç‚¹
        const p2 = { x: mouseX, y: mouseY };
        
        // æ›´æ–°è·¯å¾„
        updatePath(tempPath, p1, p2, state.lineType);
      }
    }

    function createConnection(srcCard, tgtCard, srcAnchor, tgtAnchor, lineType, arrowType) {
      const id = `conn-${Date.now()}`;
      
      // åˆ›å»ºSVG
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      svg.style.position = 'absolute';
      svg.style.top = '0';
      svg.style.left = '0';
      svg.style.pointerEvents = 'none';
      
      // åˆ›å»ºç®­å¤´æ ‡è®°
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      
      if (arrowType !== 'none') {
        const endMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        endMarker.setAttribute('id', `arrow-end-${id}`);
        endMarker.setAttribute('viewBox', '0 0 10 10');
        endMarker.setAttribute('refX', '9');
        endMarker.setAttribute('refY', '5');
        endMarker.setAttribute('markerWidth', '6');
        endMarker.setAttribute('markerHeight', '6');
        endMarker.setAttribute('orient', 'auto');
        const polyEnd = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        polyEnd.setAttribute('points', '0 0, 10 5, 0 10');
        polyEnd.setAttribute('fill', '#60a5fa');
        endMarker.appendChild(polyEnd);
        defs.appendChild(endMarker);
      }
      
      if (arrowType === 'double') {
        const startMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        startMarker.setAttribute('id', `arrow-start-${id}`);
        startMarker.setAttribute('viewBox', '0 0 10 10');
        startMarker.setAttribute('refX', '1');
        startMarker.setAttribute('refY', '5');
        startMarker.setAttribute('markerWidth', '6');
        startMarker.setAttribute('markerHeight', '6');
        startMarker.setAttribute('orient', 'auto');
        const polyStart = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        polyStart.setAttribute('points', '10 0, 0 5, 10 10');
        polyStart.setAttribute('fill', '#60a5fa');
        startMarker.appendChild(polyStart);
        defs.appendChild(startMarker);
      }
      
      svg.appendChild(defs);
      
      // åˆ›å»ºè·¯å¾„
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('stroke', '#60a5fa');
      path.setAttribute('stroke-width', '2.5');
      path.setAttribute('fill', 'none');
      path.setAttribute('class', 'connection-path');
      path.dataset.connId = id;
      
      if (arrowType === 'single') {
        path.setAttribute('marker-end', `url(#arrow-end-${id})`);
      } else if (arrowType === 'double') {
        path.setAttribute('marker-end', `url(#arrow-end-${id})`);
        path.setAttribute('marker-start', `url(#arrow-start-${id})`);
      }
      
      svg.appendChild(path);
      connectionsContainer.appendChild(svg);
      
      // åˆ›å»ºæ ‡ç­¾
      const label = document.createElement('div');
      label.className = 'connection-label';
      label.innerText = 'å…³ç³»';
      label.dataset.connId = id;
      container.appendChild(label);
      
      const conn = {
        id,
        src: srcCard.id,
        tgt: tgtCard.id,
        srcAnchor,
        tgtAnchor,
        lineType,
        arrowType,
        svg,
        path,
        labelEl: label,
        label: 'å…³ç³»'
      };
      
      state.connections.push(conn);
      setupLabelEdit(label);
      setupPathDelete(path);
      updateConnection(conn);
    }

    function getAnchorPoint(card, anchor) {
      const x = card.x;
      const y = card.y;
      const w = card.width;
      const h = card.height;
      
      switch (anchor) {
        case 'top': return { x: x + w / 2, y: y };
        case 'right': return { x: x + w, y: y + h / 2 };
        case 'bottom': return { x: x + w / 2, y: y + h };
        case 'left': return { x: x, y: y + h / 2 };
        default: return { x: x + w / 2, y: y + h / 2 };
      }
    }

    function updatePath(path, p1, p2, lineType) {
      let d;
      if (lineType === 'straight') {
        // ç›´çº¿
        d = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
      } else {
        // æŠ˜çº¿ï¼šè®¡ç®—ä¸­é—´ç‚¹
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        
        let midX, midY;
        if (Math.abs(dx) > Math.abs(dy)) {
          // æ°´å¹³ä¸»å¯¼
          midX = (p1.x + p2.x) / 2;
          midY = p1.y + dy / 3;
        } else {
          // å‚ç›´ä¸»å¯¼
          midX = p1.x + dx / 3;
          midY = (p1.y + p2.y) / 2;
        }
        
        d = `M ${p1.x} ${p1.y} L ${midX} ${midY} L ${p2.x} ${p2.y}`;
      }
      
      path.setAttribute('d', d);
    }

    function updateConnection(conn) {
      const src = state.cards.find(c => c.id === conn.src);
      const tgt = state.cards.find(c => c.id === conn.tgt);
      if (!src || !tgt) return;
      
      const p1 = getAnchorPoint(src, conn.srcAnchor);
      const p2 = getAnchorPoint(tgt, conn.tgtAnchor);
      
      updatePath(conn.path, p1, p2, conn.lineType);
      
      // æ›´æ–°æ ‡ç­¾ä½ç½®
      if (conn.lineType === 'straight') {
        conn.labelEl.style.left = `${(p1.x + p2.x) / 2}px`;
        conn.labelEl.style.top = `${(p1.y + p2.y) / 2}px`;
      } else {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        
        let midX, midY;
        if (Math.abs(dx) > Math.abs(dy)) {
          midX = (p1.x + p2.x) / 2;
          midY = p1.y + dy / 3;
        } else {
          midX = p1.x + dx / 3;
          midY = (p1.y + p2.y) / 2;
        }
        
        conn.labelEl.style.left = `${midX}px`;
        conn.labelEl.style.top = `${midY}px`;
      }
    }

    function redrawConnections() {
      state.connections.forEach(updateConnection);
    }

    function setupLabelEdit(label) {
      label.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
        
        // åˆ é™¤æ¨¡å¼ä¸‹ä¸ç¼–è¾‘
        if (state.deleteMode) return;
        
        const input = document.createElement('input');
        input.value = label.innerText;
        input.style.cssText = `
          width: 80px; padding: 2px 5px; border: 1px solid #fbbf24;
          border-radius: 10px; background: rgba(30, 41, 59, 0.95);
          color: white; text-align: center; font-size: 0.8rem;
          outline: none; pointer-events: auto;
          font-family: -apple-system, BlinkMacSystemFont, 'PingFang SC', 'Microsoft YaHei', sans-serif;
        `;
        label.innerHTML = '';
        label.appendChild(input);
        input.focus();
        
        // é€‰æ‹©æ‰€æœ‰æ–‡æœ¬
        input.select();
        
        const save = () => {
          const text = input.value.trim() || 'å…³ç³»';
          label.innerHTML = text;
          const conn = state.connections.find(c => c.labelEl === label);
          if (conn) conn.label = text;
        };
        
        input.addEventListener('blur', save);
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            save();
            label.blur();
          }
        });
        
        // é˜²æ­¢å†’æ³¡
        input.addEventListener('pointerdown', (e) => e.stopPropagation());
      });
    }

    function setupPathDelete(path) {
      path.addEventListener('pointerdown', (e) => {
        if (state.deleteMode) {
          e.stopPropagation();
          const id = path.dataset.connId;
          deleteConnection(id);
        }
      });
    }

    function deleteConnection(id) {
      const conn = state.connections.find(c => c.id === id);
      if (conn) {
        conn.svg.remove();
        conn.labelEl.remove();
        state.connections = state.connections.filter(c => c.id !== id);
      }
    }

    function setupEventListeners() {
      document.getElementById('connectBtn').addEventListener('click', () => {
        if (state.connectMode) {
          cancelConnectMode();
        } else {
          startConnectMode();
        }
      });

      document.getElementById('deleteBtn').addEventListener('click', () => {
        state.deleteMode = !state.deleteMode;
        const btn = document.getElementById('deleteBtn');
        
        if (state.deleteMode) {
          btn.classList.add('delete-mode');
          btn.textContent = 'é€€å‡ºåˆ é™¤';
          
          // å–æ¶ˆè¿çº¿æ¨¡å¼
          if (state.connectMode) {
            cancelConnectMode();
          }
          
          // é«˜äº®æ‰€æœ‰è¿æ¥
          document.querySelectorAll('.connection-path').forEach(path => {
            path.style.stroke = '#f87171';
            path.style.strokeWidth = '3';
          });
          
          document.querySelectorAll('.connection-label').forEach(label => {
            label.style.borderColor = '#f87171';
            label.style.background = 'rgba(185, 28, 28, 0.8)';
          });
          
          // éšè—é¢œè‰²é€‰æ‹©å™¨
          hideColorPicker();
          
          instructions.innerHTML = `
            <span class="highlight-instruction">ç‚¹å‡»è¿çº¿æˆ–æ ‡ç­¾</span>åˆ é™¤å…³ç³»
          `;
        } else {
          btn.classList.remove('delete-mode');
          btn.textContent = 'åˆ é™¤è¿çº¿';
          
          // æ¢å¤è¿æ¥æ ·å¼
          document.querySelectorAll('.connection-path').forEach(path => {
            path.style.stroke = '#60a5fa';
            path.style.strokeWidth = '2.5';
          });
          
          document.querySelectorAll('.connection-label').forEach(label => {
            label.style.borderColor = '#60a5fa';
            label.style.background = 'rgba(15, 23, 42, 0.9)';
          });
          
          instructions.innerHTML = `
            <span class="highlight-instruction">æ‹–æ‹½</span>å¡ç‰‡è°ƒæ•´ä½ç½® â€¢ 
            <span class="highlight-instruction">ç‚¹å‡»</span>å¡ç‰‡ä¿®æ”¹é¢œè‰² â€¢ 
            <span class="highlight-instruction">ç‚¹å‡»åº•éƒ¨æŒ‰é’®</span>åˆ›å»º/åˆ é™¤è¿çº¿
          `;
        }
      });

      container.addEventListener('click', (e) => {
        if (!state.deleteMode) return;
        
        // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†æ ‡ç­¾
        const label = e.target.closest('.connection-label');
        if (label) {
          const id = label.dataset.connId;
          deleteConnection(id);
        }
      });

      // è·Ÿè¸ªé¼ æ ‡ä½ç½®ç”¨äºä¸´æ—¶è¿çº¿
      container.addEventListener('pointermove', (e) => {
        if (state.connectMode && state.connectingCard) {
          state.lastMouseX = e.clientX - container.getBoundingClientRect().left;
          state.lastMouseY = e.clientY - container.getBoundingClientRect().top;
          updateTempConnection();
        }
      });

      // å…³é—­å¼¹çª—å½“ç‚¹å‡»èƒŒæ™¯
      document.getElementById('exportModal').addEventListener('click', (e) => {
        if (e.target === document.getElementById('exportModal')) {
          document.getElementById('exportModal').style.display = 'none';
        }
      });

      document.getElementById('exportBtn').addEventListener('click', () => {
        document.getElementById('exportModal').style.display = 'flex';
      });

      document.getElementById('exportJpg').addEventListener('click', exportJPG);
      document.getElementById('exportXml').addEventListener('click', exportXML);

      window.addEventListener('resize', checkOrientation);
      
      // ç‚¹å‡»ç©ºç™½å¤„éšè—UI
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.card') && 
            !e.target.closest('.color-picker') && 
            !e.target.closest('.connection-label') &&
            !e.target.closest('.toolbar') &&
            !e.target.closest('.connection-type-bar')) {
          hideColorPicker();
          
          // å¦‚æœåœ¨è¿çº¿æ¨¡å¼ä¸”æ²¡æœ‰é€‰æ‹©æºå¡ç‰‡ï¼Œå–æ¶ˆè¿çº¿æ¨¡å¼
          if (state.connectMode && !state.connectingCard) {
            cancelConnectMode();
          }
        }
      });
      
      // å–æ¶ˆè¿çº¿æ¨¡å¼çš„å¿«æ·æ–¹å¼
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && (state.connectMode || state.deleteMode)) {
          if (state.connectMode) cancelConnectMode();
          if (state.deleteMode) {
            state.deleteMode = false;
            document.getElementById('deleteBtn').classList.remove('delete-mode');
            document.getElementById('deleteBtn').textContent = 'åˆ é™¤è¿çº¿';
          }
        }
      });
    }

    function initWatermark() {
      const now = new Date();
      const dateStr = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
      document.querySelector('.watermark').textContent = `ç”Ÿæˆäº ${dateStr} â€¢ é¡¹ç›®ç®¡ç†ä¹‹èˆŸ`;
    }

    function checkOrientation() {
      const alert = document.querySelector('.orientation-alert');
      const container = document.getElementById('container');
      
      if (window.innerHeight > window.innerWidth) {
        alert.style.display = 'flex';
        container.style.display = 'none';
        
        // ç¡®ä¿è¿çº¿æ¨¡å¼è¢«å–æ¶ˆ
        if (state.connectMode) cancelConnectMode();
        if (state.deleteMode) {
          state.deleteMode = false;
          document.getElementById('deleteBtn').classList.remove('delete-mode');
          document.getElementById('deleteBtn').textContent = 'åˆ é™¤è¿çº¿';
        }
      } else {
        alert.style.display = 'none';
        container.style.display = 'block';
        
        // é€‚é…æ¨ªå±å°ºå¯¸
        updateCardPositions();
      }
    }

    function updateCardPositions() {
      const w = container.clientWidth;
      const h = container.clientHeight;
      
      // ä¸º10ä¸ªå¡ç‰‡è§„åˆ’æœ€ä½³ä½ç½®
      const positions = getOptimalPositions(w, h);
      
      state.cards.forEach((card, i) => {
        if (i < positions.length) {
          card.x = positions[i].x;
          card.y = positions[i].y;
          card.el.style.left = `${card.x}px`;
          card.el.style.top = `${card.y}px`;
        }
      });
      
      redrawConnections();
    }

    function getOptimalPositions(width, height) {
      // ä¸ºiPhone 13 miniä¼˜åŒ–çš„ä½ç½®
      const cardW = 110, cardH = 95;
      const padding = 15;
      
      // è®¡ç®—æ¯è¡Œå¯æ”¾ç½®çš„å¡ç‰‡æ•°é‡
      const cardsPerRow = Math.floor((width - 2 * padding) / (cardW + padding));
      const rows = Math.ceil(10 / cardsPerRow);
      
      // è®¡ç®—èµ·å§‹ä½ç½®ä½¿å¡ç‰‡å±…ä¸­
      const totalWidth = cardsPerRow * cardW + (cardsPerRow - 1) * padding;
      const startX = (width - totalWidth) / 2;
      const totalHeight = rows * cardH + (rows - 1) * padding;
      const startY = (height - totalHeight) / 2;
      
      const positions = [];
      for (let i = 0; i < 10; i++) {
        const row = Math.floor(i / cardsPerRow);
        const col = i % cardsPerRow;
        const x = startX + col * (cardW + padding);
        const y = startY + row * (cardH + padding);
        
        // ç¡®ä¿åœ¨è¾¹ç•Œå†…
        positions.push({
          x: Math.max(padding, Math.min(width - cardW - padding, x)),
          y: Math.max(padding, Math.min(height - cardH - padding, y))
        });
      }
      
      return positions;
    }

    // Export functions
    async function exportJPG() {
      document.getElementById('exportModal').style.display = 'none';
      const loading = document.getElementById('loading');
      loading.style.display = 'flex';

      try {
        // ä¸´æ—¶éšè—UIå…ƒç´ 
        const toolbar = document.querySelector('.toolbar');
        const cp = document.getElementById('colorPicker');
        const tb = document.getElementById('typeBar');
        const watermark = document.querySelector('.watermark');
        const instr = document.getElementById('instructions');
        
        const origTb = toolbar.style.display;
        const origCp = cp.style.display;
        const origTbDisp = tb.style.display;
        const origInstrDisp = instr.style.display;
        
        toolbar.style.display = 'none';
        cp.style.display = 'none';
        tb.style.display = 'none';
        instr.style.display = 'none';
        
        // æ·»åŠ å¯¼å‡ºæ°´å°
        const exportWatermark = document.createElement('div');
        exportWatermark.className = 'watermark';
        exportWatermark.style.bottom = '5px';
        exportWatermark.style.right = '10px';
        exportWatermark.style.fontSize = '0.7rem';
        exportWatermark.textContent = `é¡¹ç›®ç®¡ç†ä¹‹èˆŸ â€¢ ${new Date().toLocaleDateString('zh-CN')}`;
        container.appendChild(exportWatermark);
        
        const canvas = await html2canvas(container, {
          backgroundColor: null,
          scale: 2,
          useCORS: true,
          allowTaint: true,
          logging: false
        });
        
        // æ¢å¤åŸå§‹çŠ¶æ€
        toolbar.style.display = origTb;
        cp.style.display = origCp;
        tb.style.display = origTbDisp;
        instr.style.display = origInstrDisp;
        container.removeChild(exportWatermark);
        
        // åˆ›å»ºä¸‹è½½é“¾æ¥
        const link = document.createElement('a');
        link.download = `é¡¹ç›®ç®¡ç†ä¹‹èˆŸ_${new Date().toISOString().slice(0, 10)}.jpg`;
        link.href = canvas.toDataURL('image/jpeg', 0.92);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
      } catch (e) {
        alert('å¯¼å‡ºå›¾ç‰‡å¤±è´¥ï¼Œè¯·é‡è¯•');
        console.error(e);
      } finally {
        loading.style.display = 'none';
      }
    }

    function exportXML() {
      document.getElementById('exportModal').style.display = 'none';

      let xml = `<?xml version="1.0" encoding="UTF-8"?>\n<projectManagementBoat version="1.3">\n`;
      
      // å…ƒæ•°æ®
      xml += `  <metadata>\n`;
      xml += `    <created>${new Date().toISOString()}</created>\n`;
      xml += `    <device>${navigator.userAgent}</device>\n`;
      xml += `  </metadata>\n`;

      // Cards
      xml += `  <cards>\n`;
      state.cards.forEach(card => {
        const idx = parseInt(card.id.split('-')[1]);
        xml += `    <card id="${card.id}" x="${Math.round(card.x)}" y="${Math.round(card.y)}" color="${card.color}" textColor="${card.textColor}">\n`;
        xml += `      <title><![CDATA[${cards[idx].title}]]></title>\n`;
        xml += `      <subtitle><![CDATA[${cards[idx].sub}]]></subtitle>\n`;
        xml += `    </card>\n`;
      });
      xml += `  </cards>\n`;

      // Connections
      xml += `  <connections>\n`;
      state.connections.forEach(conn => {
        xml += `    <connection id="${conn.id}" source="${conn.src}" target="${conn.tgt}" `;
        xml += `srcAnchor="${conn.srcAnchor}" tgtAnchor="${conn.tgtAnchor}" lineType="${conn.lineType}" arrowType="${conn.arrowType}" `;
        xml += `label="${escapeXml(conn.label)}"/>\n`;
      });
      xml += `  </connections>\n`;

      xml += `</projectManagementBoat>`;

      const blob = new Blob([xml], { type: 'application/xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `é¡¹ç›®ç®¡ç†ä¹‹èˆŸ_${new Date().toISOString().slice(0, 10)}.xml`;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    }

    function escapeXml(str) {
      if (!str) return '';
      return str.replace(/[&<>"']/g, (c) => {
        switch (c) {
          case '&': return '&amp;';
          case '<': return '&lt;';
          case '>': return '&gt;';
          case '"': return '&quot;';
          case "'": return '&apos;';
          default: return c;
        }
      });
    }

    // Start
    document.addEventListener('DOMContentLoaded', () => {
      // ç¡®ä¿å®¹å™¨éšè—ç›´åˆ°æ£€æŸ¥æ–¹å‘
      document.getElementById('container').style.display = 'none';
      init();
    });
  </script>
</body>
</html>
