<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#1e3a8a" />
  <meta name="description" content="é¡¹ç›®ç®¡ç†ä¹‹èˆŸ - ä¸“ä¸ºå°å±è®¾å¤‡ä¼˜åŒ–çš„é¡¹ç›®ç®¡ç†å¯è§†åŒ–å·¥å…·" />
  <title>é¡¹ç›®ç®¡ç†ä¹‹èˆŸ</title>

  <!-- PWA Manifest (å†…è”) -->
  <link rel="manifest" href="application/manifest+json;base64,ewogICJuYW1lIjogIueVmeaKpeWtpuivvyIsCiAgInNob3J0X25hbWUiOiAi55WZ5oql5a2m6K%2F%2FIiwKICAic3RhcnRfdXJsIjogIi4vIiwKICAiZGlzcGxheSI6ICJzdGFuZGFsb25lIiwKICAiYmFja2dyb3VuZF9jb2xvciI6ICIjMWUzYThhIiwKICAidGhlbWVfY29sb3IiOiAiIzFlM2E4YSIsCiAgImljb25zIjogWwogICAgewogICAgICAic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIj48cGF0aCBmaWxsPSIjMWUzYThhIiBkPSJNMCAwaDE5MnYxOTJIMHoiLz48dGV4dCB4PSI5NiIgeT0iOTYiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSI0MCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiPuWVmeaKpeWtpuivvyAgPC90ZXh0Pjwvc3ZnPg==IiwKICAgICAgInNpemVzIjogIjE5MngxOTIiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIgogICAgfQogIF0KfQo=">

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'PingFang SC', 'Microsoft YaHei', sans-serif;
      background: linear-gradient(135deg, #0f172a, #1e3a8a);
      color: white;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      position: relative;
    }

    .orientation-alert {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      text-align: center;
      padding: 20px;
    }

    .orientation-alert h2 {
      font-size: 2rem;
      margin-bottom: 15px;
      color: #60a5fa;
    }

    .orientation-alert p {
      font-size: 1.2rem;
      color: #cbd5e1;
      max-width: 90%;
    }

    .container {
      position: relative;
      width: 100%;
      height: 100%;
      display: none;
      overflow: hidden;
    }

    .card {
      position: absolute;
      width: 110px;
      height: 95px;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 6px;
      text-align: center;
      cursor: grab;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
      border: 2px solid #60a5fa;
      transition: transform 0.2s, box-shadow 0.2s;
      z-index: 10;
      backface-visibility: hidden;
      will-change: transform;
    }

    .card.dragging {
      transform: scale(1.05);
      z-index: 20;
      box-shadow: 0 0 0 3px #fbbf24, 0 0 15px rgba(251, 191, 36, 0.6);
    }

    .card:active {
      cursor: grabbing;
    }

    .card-title {
      font-weight: bold;
      font-size: 0.95rem;
      line-height: 1.3;
      margin-bottom: 2px;
    }

    .card-sub {
      font-size: 0.75rem;
      line-height: 1.3;
    }

    .card-edge {
      position: absolute;
      background: rgba(255, 255, 255, 0.2);
      z-index: 12;
      pointer-events: auto;
      transition: background 0.2s;
    }
    
    .card-top { top: 0; left: 0; width: 100%; height: 15px; border-top-left-radius: 10px; border-top-right-radius: 10px; }
    .card-right { top: 0; right: 0; width: 15px; height: 100%; border-top-right-radius: 10px; border-bottom-right-radius: 10px; }
    .card-bottom { bottom: 0; left: 0; width: 100%; height: 15px; border-bottom-left-radius: 10px; border-bottom-right-radius: 10px; }
    .card-left { top: 0; left: 0; width: 15px; height: 100%; border-top-left-radius: 10px; border-bottom-left-radius: 10px; }

    .card-edge:hover {
      background: rgba(96, 165, 250, 0.4);
    }

    .card.highlight {
      box-shadow: 0 0 0 3px #fbbf24, 0 0 15px rgba(251, 191, 36, 0.6);
    }

    .card.source-card {
      box-shadow: 0 0 0 3px #10b981, 0 0 15px rgba(16, 185, 129, 0.7);
    }

    .toolbar {
      position: absolute;
      bottom: 15px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      gap: 15px;
      z-index: 100;
      padding: 0 10px;
    }

    .btn {
      padding: 10px 18px;
      border-radius: 25px;
      border: none;
      font-weight: bold;
      font-size: 0.95rem;
      cursor: pointer;
      background: rgba(30, 58, 138, 0.92);
      color: white;
      border: 2px solid #60a5fa;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.35);
      min-width: 100px;
      touch-action: manipulation;
      transition: all 0.2s;
    }

    .btn:active {
      transform: scale(0.97);
    }

    .btn:hover {
      background: rgba(59, 130, 246, 0.95);
    }

    .btn.delete-mode {
      background: rgba(185, 28, 28, 0.95);
      border-color: #f87171;
    }

    .btn.connect-mode {
      background: rgba(16, 185, 129, 0.95);
      border-color: #10b981;
    }

    .color-picker {
      position: absolute;
      background: rgba(15, 23, 42, 0.95);
      border: 2px solid #60a5fa;
      border-radius: 12px;
      padding: 12px 8px;
      display: none;
      z-index: 50;
      box-shadow: 0 5px 18px rgba(0, 0, 0, 0.5);
      min-width: 220px;
    }

    .color-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
    }

    .color-item {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid #60a5fa;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .color-item:hover, .color-item.selected {
      transform: scale(1.2);
      box-shadow: 0 0 0 3px white;
    }

    .connections-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }

    .temp-connection {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 7;
    }

    .connection-path {
      pointer-events: auto !important;
      cursor: pointer;
    }

    .connection-label {
      position: absolute;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid #60a5fa;
      border-radius: 14px;
      padding: 4px 10px;
      font-size: 0.8rem;
      transform: translate(-50%, -50%);
      pointer-events: auto;
      cursor: pointer;
      max-width: 120px;
      text-align: center;
      word-break: break-word;
      z-index: 6;
      touch-action: manipulation;
    }

    /* å…¨æ–°è®¾è®¡çš„è¿çº¿é€‰æ‹©å™¨ - ç°ä»£åŒ–UI */
    .connection-selector {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to top, #0f172a, #1e293b);
      border-top: 2px solid #38bdf8;
      border-radius: 28px 28px 0 0;
      padding: 20px 15px 30px;
      z-index: 150;
      transform: translateY(100%);
      transition: transform 0.4s cubic-bezier(0.23, 1, 0.32, 1);
      box-shadow: 0 -4px 25px rgba(0, 0, 0, 0.4);
      max-height: 85vh;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .connection-selector.active {
      transform: translateY(0);
    }

    .selector-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 5px 15px;
      border-bottom: 1px solid rgba(56, 189, 248, 0.2);
      margin-bottom: 20px;
    }

    .selector-title {
      font-size: 1.3rem;
      font-weight: 700;
      color: #38bdf8;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .selector-title svg {
      width: 24px;
      height: 24px;
    }

    .selector-subtitle {
      font-size: 0.95rem;
      color: #94a3b8;
      margin-top: 4px;
      margin-left: 34px;
    }

    .selector-close {
      background: rgba(100, 116, 139, 0.3);
      border: none;
      width: 36px;
      height: 36px;
      border-radius: 18px;
      color: white;
      font-weight: bold;
      font-size: 1.4rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .selector-close:hover {
      background: rgba(100, 116, 139, 0.5);
      transform: rotate(90deg);
    }

    .selector-content {
      padding: 0 5px;
    }

    .selector-section {
      margin-bottom: 25px;
    }

    .section-title {
      font-size: 1.1rem;
      color: #cbd5e1;
      margin-bottom: 18px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .section-title svg {
      width: 20px;
      height: 20px;
      color: #38bdf8;
    }

    /* è¿çº¿ç±»å‹é€‰æ‹© - å…¨æ–°å¡ç‰‡å¼è®¾è®¡ */
    .line-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .line-option {
      background: rgba(30, 41, 59, 0.7);
      border: 1px solid rgba(56, 189, 248, 0.3);
      border-radius: 16px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .line-option:hover {
      border-color: rgba(56, 189, 248, 0.6);
      background: rgba(30, 41, 59, 0.9);
    }

    .line-option.selected {
      background: rgba(12, 74, 110, 0.9);
      border-color: #38bdf8;
      transform: translateX(5px);
      box-shadow: 0 4px 15px rgba(0, 100, 255, 0.25);
    }

    .line-preview-container {
      width: 90px;
      height: 60px;
      background: rgba(0, 0, 0, 0.15);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      position: relative;
      overflow: hidden;
    }

    .line-preview-bg {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: space-around;
    }

    .line-preview-card {
      width: 22px;
      height: 18px;
      background: rgba(56, 189, 248, 0.7);
      border-radius: 4px;
    }

    .line-preview {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .line-preview svg {
      width: 100%;
      height: 100%;
    }

    .line-preview path {
      stroke: #94a3b8;
      stroke-width: 2;
      fill: none;
      transition: stroke 0.2s;
    }

    .line-option.selected .line-preview path {
      stroke: #38bdf8;
      stroke-width: 2.5;
    }

    .line-info {
      flex: 1;
    }

    .line-name {
      font-size: 1.1rem;
      font-weight: 600;
      color: white;
      margin-bottom: 3px;
    }

    .line-desc {
      font-size: 0.85rem;
      color: #94a3b8;
      line-height: 1.4;
    }

    /* ç®­å¤´ç±»å‹é€‰æ‹© - å…¨æ–°è®¾è®¡ */
    .arrow-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .arrow-option {
      background: rgba(30, 41, 59, 0.7);
      border: 1px solid rgba(56, 189, 248, 0.3);
      border-radius: 16px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .arrow-option:hover {
      border-color: rgba(56, 189, 248, 0.6);
      background: rgba(30, 41, 59, 0.9);
    }

    .arrow-option.selected {
      background: rgba(12, 74, 110, 0.9);
      border-color: #38bdf8;
      transform: translateX(5px);
      box-shadow: 0 4px 15px rgba(0, 100, 255, 0.25);
    }

    .arrow-preview-container {
      width: 90px;
      height: 40px;
      background: rgba(0, 0, 0, 0.15);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      position: relative;
      overflow: hidden;
    }

    .arrow-preview {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .arrow-preview svg {
      width: 100%;
      height: 100%;
    }

    .arrow-preview path, .arrow-preview polygon {
      stroke: #94a3b8;
      stroke-width: 1.5;
      fill: none;
      transition: all 0.2s;
    }

    .arrow-option.selected .arrow-preview path,
    .arrow-option.selected .arrow-preview polygon {
      stroke: #38bdf8;
      stroke-width: 2;
      fill: #38bdf8;
    }

    .arrow-info {
      flex: 1;
    }

    .arrow-name {
      font-size: 1.1rem;
      font-weight: 600;
      color: white;
      margin-bottom: 3px;
    }

    .arrow-desc {
      font-size: 0.85rem;
      color: #94a3b8;
      line-height: 1.4;
    }

    /* æ“ä½œæŒ‰é’® - å…¨æ–°è®¾è®¡ */
    .selector-actions {
      display: flex;
      gap: 15px;
      padding: 0 5px;
      margin-top: 10px;
      margin-bottom: 10px;
    }

    .action-btn {
      flex: 1;
      padding: 14px 10px;
      border-radius: 20px;
      border: none;
      font-weight: bold;
      font-size: 1.05rem;
      cursor: pointer;
      transition: all 0.25s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .action-btn:active {
      transform: translateY(2px);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    .confirm-btn {
      background: linear-gradient(135deg, #0ea5e9, #0284c7);
      color: white;
      border: 2px solid #38bdf8;
    }

    .confirm-btn:hover {
      background: linear-gradient(135deg, #0284c7, #0369a1);
      transform: translateY(-2px);
      box-shadow: 0 6px 18px rgba(2, 132, 199, 0.4);
    }

    .cancel-btn {
      background: linear-gradient(135deg, #475569, #334155);
      color: white;
      border: 2px solid #64748b;
    }

    .cancel-btn:hover {
      background: linear-gradient(135deg, #334155, #1e293b);
      transform: translateY(-2px);
      box-shadow: 0 6px 18px rgba(51, 65, 85, 0.4);
    }

    .action-icon {
      font-size: 1.6rem;
      font-weight: bold;
    }

    .action-text {
      font-size: 1.1rem;
      font-weight: 600;
    }

    .export-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.92);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 200;
      touch-action: none;
    }

    .modal-content {
      background: rgba(15, 23, 42, 0.97);
      border: 2px solid #60a5fa;
      border-radius: 18px;
      padding: 25px;
      width: 90%;
      max-width: 380px;
      text-align: center;
    }

    .modal-title {
      font-size: 1.4rem;
      margin-bottom: 15px;
      color: #60a5fa;
    }

    .export-options {
      display: flex;
      gap: 15px;
      margin: 15px 0;
      flex-wrap: wrap;
      justify-content: center;
    }

    .export-option {
      background: rgba(30, 58, 138, 0.8);
      border: 1px solid #60a5fa;
      border-radius: 12px;
      padding: 12px;
      width: 140px;
      cursor: pointer;
      transition: all 0.2s;
      touch-action: manipulation;
    }

    .export-option:hover, .export-option:active {
      background: rgba(59, 130, 246, 0.85);
      transform: translateY(-2px);
    }

    .loading {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.88);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 300;
      touch-action: none;
    }

    .spinner {
      width: 35px;
      height: 35px;
      border: 3px solid rgba(96, 165, 250, 0.3);
      border-top: 3px solid #60a5fa;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 12px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-text {
      font-size: 1.1rem;
      text-align: center;
      padding: 0 20px;
    }

    .watermark {
      position: absolute;
      bottom: 8px;
      right: 10px;
      font-size: 0.75rem;
      color: rgba(156, 163, 175, 0.8);
      z-index: 1;
    }

    .instructions {
      position: absolute;
      top: 12px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 0.95rem;
      color: #94a3b8;
      z-index: 100;
      padding: 0 20px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }

    .highlight-instruction {
      color: #fbbf24;
      font-weight: bold;
    }

    @media (max-aspect-ratio: 13/9) {
      .orientation-alert {
        display: flex;
      }
    }

    /* ç¡®ä¿åœ¨ iOS å®‰å…¨åŒºåŸŸå†… */
    @supports (padding-top: env(safe-area-inset-top)) {
      body {
        padding-top: env(safe-area-inset-top);
      }
      
      .toolbar {
        bottom: calc(15px + env(safe-area-inset-bottom));
      }
      
      .connection-selector {
        padding-bottom: calc(30px + env(safe-area-inset-bottom));
      }
    }
  </style>
</head>
<body>
  <div class="orientation-alert">
    <h2>ğŸ“± è¯·æ¨ªå±ä½¿ç”¨</h2>
    <p>ä¸ºäº†è·å¾—æœ€ä½³ä½“éªŒï¼Œè¯·å°†æ‰‹æœºæ—‹è½¬è‡³æ¨ªå±æ¨¡å¼</p>
  </div>

  <div class="container" id="container">
    <div class="connections-container" id="connectionsContainer"></div>
    <div class="temp-connection" id="tempConnection"></div>
    <!-- Cards will be inserted by JS -->

    <div class="toolbar">
      <button class="btn" id="connectBtn">åˆ›å»ºè¿çº¿</button>
      <button class="btn" id="deleteBtn">åˆ é™¤è¿çº¿</button>
      <button class="btn" id="exportBtn">å¯¼å‡ºç»“æœ</button>
    </div>

    <div class="color-picker" id="colorPicker">
      <div class="color-grid" id="colorGrid"></div>
    </div>

    <div class="instructions" id="instructions">
      <span class="highlight-instruction">æ‹–æ‹½</span>å¡ç‰‡è°ƒæ•´ä½ç½® â€¢ 
      <span class="highlight-instruction">ç‚¹å‡»</span>å¡ç‰‡ä¿®æ”¹é¢œè‰² â€¢ 
      <span class="highlight-instruction">ç‚¹å‡»åº•éƒ¨æŒ‰é’®</span>åˆ›å»º/åˆ é™¤è¿çº¿
    </div>

    <div class="watermark">é¡¹ç›®ç®¡ç†ä¹‹èˆŸ v2.1</div>
  </div>

  <!-- å…¨æ–°è®¾è®¡çš„è¿çº¿é€‰æ‹©å™¨ -->
  <div class="connection-selector" id="connectionSelector">
    <div class="selector-header">
      <div>
        <div class="selector-title">
          <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 5L12 19M12 19L5 12M12 19L19 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          è¿æ¥å…³ç³»è®¾ç½®
        </div>
        <div class="selector-subtitle">é€‰æ‹©è¿çº¿æ ·å¼ä¸ç®­å¤´ç±»å‹</div>
      </div>
      <button class="selector-close" id="closeSelector">Ã—</button>
    </div>
    
    <div class="selector-content">
      <div class="selector-section">
        <div class="section-title">
          <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M5 12H19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M5 7H19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M5 17H19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          è¿çº¿æ ·å¼
        </div>
        
        <div class="line-options">
          <div class="line-option selected" data-type="straight">
            <div class="line-preview-container">
              <div class="line-preview-bg">
                <div class="line-preview-card"></div>
                <div class="line-preview-card"></div>
              </div>
              <div class="line-preview">
                <svg viewBox="0 0 100 60" xmlns="http://www.w3.org/2000/svg">
                  <path d="M 20 30 L 80 30" />
                </svg>
              </div>
            </div>
            <div class="line-info">
              <div class="line-name">ç›´çº¿è¿æ¥</div>
              <div class="line-desc">ç›´æ¥è¿æ¥ä¸¤ä¸ªå¡ç‰‡ï¼Œç®€æ´æ˜äº†</div>
            </div>
          </div>
          <div class="line-option" data-type="ortho">
            <div class="line-preview-container">
              <div class="line-preview-bg">
                <div class="line-preview-card"></div>
                <div class="line-preview-card"></div>
              </div>
              <div class="line-preview">
                <svg viewBox="0 0 100 60" xmlns="http://www.w3.org/2000/svg">
                  <path d="M 20 30 L 50 30 L 50 15 L 80 15" />
                </svg>
              </div>
            </div>
            <div class="line-info">
              <div class="line-name">ç›´è§’æŠ˜çº¿</div>
              <div class="line-desc">90åº¦ç›´è§’è½¬æŠ˜ï¼Œé¿å…äº¤å‰é‡å </div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="selector-section">
        <div class="section-title">
          <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 5V19M12 19L5 12M12 19L19 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          ç®­å¤´ç±»å‹
        </div>
        
        <div class="arrow-options">
          <div class="arrow-option" data-type="none">
            <div class="arrow-preview-container">
              <div class="arrow-preview">
                <svg viewBox="0 0 100 40" xmlns="http://www.w3.org/2000/svg">
                  <path d="M 20 20 L 80 20" />
                </svg>
              </div>
            </div>
            <div class="arrow-info">
              <div class="arrow-name">æ— ç®­å¤´</div>
              <div class="arrow-desc">è¡¨ç¤ºåŒå‘æˆ–éæ–¹å‘æ€§å…³ç³»</div>
            </div>
          </div>
          <div class="arrow-option selected" data-type="single">
            <div class="arrow-preview-container">
              <div class="arrow-preview">
                <svg viewBox="0 0 100 40" xmlns="http://www.w3.org/2000/svg">
                  <defs>
                    <marker id="arrowhead-single" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                      <polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8" stroke="#94a3b8" stroke-width="1" />
                    </marker>
                  </defs>
                  <path d="M 20 20 L 80 20" marker-end="url(#arrowhead-single)" />
                </svg>
              </div>
            </div>
            <div class="arrow-info">
              <div class="arrow-name">å•ç®­å¤´</div>
              <div class="arrow-desc">è¡¨ç¤ºå•å‘ä¾èµ–æˆ–å½±å“å…³ç³»</div>
            </div>
          </div>
          <div class="arrow-option" data-type="double">
            <div class="arrow-preview-container">
              <div class="arrow-preview">
                <svg viewBox="0 0 100 40" xmlns="http://www.w3.org/2000/svg">
                  <defs>
                    <marker id="arrowhead-start" markerWidth="10" markerHeight="7" refX="1" refY="3.5" orient="auto">
                      <polygon points="10 0, 0 3.5, 10 7" fill="#94a3b8" stroke="#94a3b8" stroke-width="1" />
                    </marker>
                    <marker id="arrowhead-end" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                      <polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8" stroke="#94a3b8" stroke-width="1" />
                    </marker>
                  </defs>
                  <path d="M 20 20 L 80 20" marker-start="url(#arrowhead-start)" marker-end="url(#arrowhead-end)" />
                </svg>
              </div>
            </div>
            <div class="arrow-info">
              <div class="arrow-name">åŒç®­å¤´</div>
              <div class="arrow-desc">è¡¨ç¤ºåŒå‘å½±å“æˆ–äº’èµ–å…³ç³»</div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="selector-actions">
      <button class="action-btn cancel-btn" id="cancelConnection">
        <div class="action-icon">âœ•</div>
        <div class="action-text">å–æ¶ˆ</div>
      </button>
      <button class="action-btn confirm-btn" id="confirmConnection">
        <div class="action-icon">âœ“</div>
        <div class="action-text">å®Œæˆ</div>
      </button>
    </div>
  </div>

  <div class="export-modal" id="exportModal">
    <div class="modal-content">
      <div class="modal-title">å¯¼å‡ºé¡¹ç›®ç®¡ç†æ–¹æ¡ˆ</div>
      <p>è¯·é€‰æ‹©ä¿å­˜æ ¼å¼</p>
      <div class="export-options">
        <div class="export-option" id="exportJpg">
          <svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z" fill="#60a5fa"/>
          </svg>
          <div style="margin-top: 8px; font-weight: bold;">JPG å›¾ç‰‡</div>
        </div>
        <div class="export-option" id="exportXml">
          <svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z" fill="#60a5fa"/>
          </svg>
          <div style="margin-top: 8px; font-weight: bold;">XML æ•°æ®</div>
        </div>
      </div>
      <p style="font-size: 0.8rem; color: #94a3b8; margin-top: 12px;">
        æ–‡ä»¶å°†è‡ªåŠ¨ä¸‹è½½åˆ°æ‚¨çš„è®¾å¤‡
      </p>
    </div>
  </div>

  <div class="loading" id="loading">
    <div class="spinner"></div>
    <div class="loading-text">æ­£åœ¨ç”Ÿæˆå¯¼å‡ºæ–‡ä»¶<br>è¯·ç¨å€™...</div>
  </div>

  <!-- html2canvas for JPG export -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <script>
    // Card data
    const cards = [
      { title: "èŠ±å¤šé•¿æ—¶é—´åšï¼Ÿ", sub: "è¿›åº¦ç®¡ç†" },
      { title: "å¦‚ä½•å®ç°æ•´ä½“æœ€ä¼˜ï¼Ÿ", sub: "æ•´åˆç®¡ç†" },
      { title: "å¦‚ä½•æ‰æ»¡æ„ï¼Ÿ", sub: "ä»·å€¼ç®¡ç†" },
      { title: "è°æ¥åšï¼Ÿ", sub: "èµ„æºä¸é‡‡è´­ç®¡ç†" },
      { title: "æŒ‰ä»€ä¹ˆè´¨é‡åšï¼Ÿ", sub: "è´¨é‡ç®¡ç†" },
      { title: "åšä»€ä¹ˆï¼Ÿ", sub: "èŒƒå›´ç®¡ç†" },
      { title: "ä¸ºè°åšï¼Ÿ", sub: "å¹²ç³»äººç®¡ç†" },
      { title: "å¦‚ä½•åä½œï¼Ÿ", sub: "æ²Ÿé€šç®¡ç†" },
      { title: "ç”¨å¤šå°‘æˆæœ¬åšï¼Ÿ", sub: "æˆæœ¬ç®¡ç†" },
      { title: "æœ‰å“ªäº›äºº/è´¢/äº‹ä¼šå¢åŠ éš¾åº¦ï¼Ÿ", sub: "é£é™©ç®¡ç†" }
    ];

    // 6ç§æ˜¾è‘—åŒºåˆ†çš„é¢œè‰²
    const colors = [
      "#1e3a8a", // æ·±è“
      "#0d9488", // é’ç»¿
      "#c2410c", // æ©™çº¢
      "#7e22ce", // ç´«
      "#0ea5e9", // å¤©è“
      "#ca8a04"  // é‡‘é»„
    ];

    // State
    let state = {
      cards: [],
      connections: [],
      selectedCard: null,
      connectingCard: null,
      sourceSide: null,
      deleteMode: false,
      connectMode: false,
      lineType: 'straight', // 'straight' or 'ortho'
      arrowType: 'single',  // 'none', 'single', 'double'
      isDragging: false,
      dragOffset: { x: 0, y: 0 },
      tempConnection: null,
      lastColorSelection: {}
    };

    const container = document.getElementById('container');
    const connectionsContainer = document.getElementById('connectionsContainer');
    const tempConnectionContainer = document.getElementById('tempConnection');
    const colorPicker = document.getElementById('colorPicker');
    const colorGrid = document.getElementById('colorGrid');
    const connectionSelector = document.getElementById('connectionSelector');
    const instructions = document.getElementById('instructions');

    // Init
    function init() {
      createCards();
      createColorPicker();
      setupConnectionSelector();
      setupEventListeners();
      checkOrientation();
      initWatermark();
      
      // æ·»åŠ è§¦æ‘¸åé¦ˆ
      document.body.addEventListener('touchstart', () => {}, { passive: true });
    }

    function createCards() {
      const w = container.clientWidth;
      const h = container.clientHeight;
      
      // iPhone 13 mini æ¨ªå±çº¦ 643x320pxï¼Œä¸º10ä¸ªå¡ç‰‡è§„åˆ’ä½ç½®
      const positions = [
        { x: 40, y: 40 },     { x: 180, y: 40 },    { x: 320, y: 40 },    { x: 460, y: 40 },    { x: 600, y: 40 },
        { x: 40, y: 180 },    { x: 180, y: 180 },   { x: 320, y: 180 },   { x: 460, y: 180 },   { x: 600, y: 180 }
      ];
      
      // ç¡®ä¿ä½ç½®åœ¨å±å¹•å†…
      const cardW = 110, cardH = 95;
      const padding = 15;
      
      cards.forEach((cardData, i) => {
        const card = document.createElement('div');
        card.className = 'card';
        card.dataset.id = `card-${i}`;
        
        // ä¸ºæ¯å¼ å¡ç‰‡åˆ†é…åˆå§‹é¢œè‰²ï¼ˆå¾ªç¯ä½¿ç”¨6ç§é¢œè‰²ï¼‰
        const color = colors[i % colors.length];
        card.style.backgroundColor = color;
        
        // è®¡ç®—æ–‡å­—é¢œè‰²
        const textColor = getContrastTextColor(color);
        card.style.color = textColor;
        
        // åˆ›å»ºè¾¹ç¼˜å¯ç‚¹å‡»åŒºåŸŸ
        ['top', 'right', 'bottom', 'left'].forEach(side => {
          const edge = document.createElement('div');
          edge.className = `card-edge card-${side}`;
          edge.dataset.side = side;
          card.appendChild(edge);
        });
        
        const title = document.createElement('div');
        title.className = 'card-title';
        title.innerText = cardData.title;
        title.style.color = textColor;
        
        const sub = document.createElement('div');
        sub.className = 'card-sub';
        sub.innerText = cardData.sub;
        sub.style.color = textColor;
        
        card.appendChild(title);
        card.appendChild(sub);
        
        // ä¸ºå‰6å¼ å¡ç‰‡åˆ†é…é¢„è®¾ä½ç½®ï¼Œå…¶ä½™éšæœº
        let x, y;
        if (i < positions.length) {
          x = positions[i].x;
          y = positions[i].y;
          
          // ç¡®ä¿å¡ç‰‡å®Œå…¨åœ¨å±å¹•å†…
          x = Math.max(padding, Math.min(w - cardW - padding, x));
          y = Math.max(padding, Math.min(h - cardH - padding, y));
        } else {
          x = padding + Math.random() * (w - 2 * padding - cardW);
          y = padding + Math.random() * (h - 2 * padding - cardH);
        }
        
        card.style.left = `${x}px`;
        card.style.top = `${y}px`;
        
        container.appendChild(card);
        
        state.cards.push({
          id: `card-${i}`,
          el: card,
          x: x,
          y: y,
          color: color,
          textColor: textColor,
          width: cardW,
          height: cardH
        });
        
        makeDraggable(card);
        setupCardEdges(card);
      });
    }

    function getContrastTextColor(bgColor) {
      // å°†åå…­è¿›åˆ¶é¢œè‰²è½¬æ¢ä¸º RGB
      let r, g, b;
      if (bgColor.startsWith('#')) {
        const hex = bgColor.slice(1);
        if (hex.length === 3) {
          r = parseInt(hex[0] + hex[0], 16);
          g = parseInt(hex[1] + hex[1], 16);
          b = parseInt(hex[2] + hex[2], 16);
        } else {
          r = parseInt(hex.substring(0, 2), 16);
          g = parseInt(hex.substring(2, 4), 16);
          b = parseInt(hex.substring(4, 6), 16);
        }
      } else {
        // ç®€å•å¤„ç†ï¼Œå®é™…åº”ç”¨ä¸­åº”æ›´å®Œå–„
        return '#ffffff';
      }
      
      // è®¡ç®—äº®åº¦
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      
      // äº®åº¦é˜ˆå€¼ï¼Œ128ä¸ºä¸­é—´å€¼
      return brightness < 160 ? '#ffffff' : '#000000';
    }

    function createColorPicker() {
      colorGrid.innerHTML = '';
      
      colors.forEach((color, index) => {
        const item = document.createElement('div');
        item.className = 'color-item';
        item.style.backgroundColor = color;
        
        // è®¾ç½®è¾¹æ¡†é¢œè‰²ä¸ºå¯¹æ¯”è‰²
        const borderColor = getContrastTextColor(color);
        item.style.borderColor = borderColor;
        
        item.addEventListener('click', () => {
          if (state.selectedCard) {
            // æ›´æ–°å¡ç‰‡èƒŒæ™¯è‰²
            state.selectedCard.el.style.backgroundColor = color;
            state.selectedCard.color = color;
            
            // æ›´æ–°æ–‡å­—é¢œè‰²
            const newTextColor = getContrastTextColor(color);
            state.selectedCard.textColor = newTextColor;
            
            // æ›´æ–°å­å…ƒç´ é¢œè‰²
            const title = state.selectedCard.el.querySelector('.card-title');
            const sub = state.selectedCard.el.querySelector('.card-sub');
            if (title) title.style.color = newTextColor;
            if (sub) sub.style.color = newTextColor;
            
            // æ›´æ–°çŠ¶æ€
            state.lastColorSelection[state.selectedCard.id] = index;
            
            hideColorPicker();
          }
        });
        
        colorGrid.appendChild(item);
      });
    }

    function setupConnectionSelector() {
      // è®¾ç½®è¿çº¿ç±»å‹é€‰æ‹©
      const lineOptions = connectionSelector.querySelectorAll('.line-option');
      lineOptions.forEach(option => {
        option.addEventListener('click', () => {
          state.lineType = option.dataset.type;
          
          // æ›´æ–°é€‰ä¸­çŠ¶æ€
          lineOptions.forEach(opt => opt.classList.remove('selected'));
          option.classList.add('selected');
          
          // æ›´æ–°ä¸´æ—¶è¿çº¿
          updateTempConnection();
        });
      });
      
      // è®¾ç½®ç®­å¤´ç±»å‹é€‰æ‹©
      const arrowOptions = connectionSelector.querySelectorAll('.arrow-option');
      arrowOptions.forEach(option => {
        option.addEventListener('click', () => {
          state.arrowType = option.dataset.type;
          
          // æ›´æ–°é€‰ä¸­çŠ¶æ€
          arrowOptions.forEach(opt => opt.classList.remove('selected'));
          option.classList.add('selected');
          
          // æ›´æ–°ä¸´æ—¶è¿çº¿
          updateTempConnection();
        });
      });
      
      // å…³é—­é€‰æ‹©å™¨
      document.getElementById('closeSelector').addEventListener('click', cancelConnection);
      document.getElementById('cancelConnection').addEventListener('click', cancelConnection);
      
      // ç¡®è®¤è¿æ¥
      document.getElementById('confirmConnection').addEventListener('click', confirmConnection);
      
      // åˆå§‹åŒ–é€‰ä¸­çŠ¶æ€
      document.querySelector('.line-option[data-type="straight"]').classList.add('selected');
      document.querySelector('.arrow-option[data-type="single"]').classList.add('selected');
    }

    function showConnectionSelector() {
      // å¦‚æœå·²ç»åœ¨é€‰æ‹©å™¨ä¸­ï¼Œä¸åšä»»ä½•æ“ä½œ
      if (connectionSelector.classList.contains('active')) return;
      
      connectionSelector.classList.add('active');
      
      // æš‚åœæ»šåŠ¨
      document.body.style.overflow = 'hidden';
      
      // æ›´æ–°æç¤º
      instructions.innerHTML = `
        <span class="highlight-instruction">é€‰æ‹©è¿çº¿æ ·å¼å’Œç®­å¤´ç±»å‹</span>ï¼Œç„¶å
        <span class="highlight-instruction">ç‚¹å‡»ç›®æ ‡å¡ç‰‡è¾¹ç¼˜</span>å®Œæˆè¿çº¿
      `;
    }

    function hideConnectionSelector() {
      connectionSelector.classList.remove('active');
      document.body.style.overflow = 'auto';
    }

    function cancelConnection() {
      hideConnectionSelector();
      
      if (state.connectingCard) {
        state.connectingCard.el.classList.remove('source-card');
        state.connectingCard = null;
        state.sourceSide = null;
      }
      
      state.connectMode = false;
      
      // éšè—ä¸´æ—¶è¿çº¿
      tempConnectionContainer.innerHTML = '';
      
      // æ›´æ–°æŒ‰é’®çŠ¶æ€
      document.getElementById('connectBtn').classList.remove('connect-mode');
      document.getElementById('connectBtn').textContent = 'åˆ›å»ºè¿çº¿';
      
      // æ¢å¤æç¤º
      instructions.innerHTML = `
        <span class="highlight-instruction">æ‹–æ‹½</span>å¡ç‰‡è°ƒæ•´ä½ç½® â€¢ 
        <span class="highlight-instruction">ç‚¹å‡»</span>å¡ç‰‡ä¿®æ”¹é¢œè‰² â€¢ 
        <span class="highlight-instruction">ç‚¹å‡»åº•éƒ¨æŒ‰é’®</span>åˆ›å»º/åˆ é™¤è¿çº¿
      `;
    }

    function confirmConnection() {
      // ä»…éšè—é€‰æ‹©å™¨ï¼Œä¸å–æ¶ˆè¿æ¥æ¨¡å¼
      hideConnectionSelector();
      
      instructions.innerHTML = `
        <span class="highlight-instruction">å·²é€‰æ‹©è¿çº¿æ ·å¼</span>ï¼Œç°åœ¨
        <span class="highlight-instruction">ç‚¹å‡»ç›®æ ‡å¡ç‰‡è¾¹ç¼˜</span>å®Œæˆè¿çº¿
      `;
    }

    function makeDraggable(card) {
      let isDragging = false;
      let startX, startY, initialX, initialY;
      
      card.addEventListener('pointerdown', (e) => {
        if (state.deleteMode || state.connectMode) return;
        e.preventDefault();
        
        const rect = card.getBoundingClientRect();
        startX = e.clientX;
        startY = e.clientY;
        initialX = parseFloat(card.style.left);
        initialY = parseFloat(card.style.top);
        
        isDragging = true;
        state.isDragging = true;
        
        // é«˜äº®é€‰ä¸­
        state.cards.forEach(c => c.el.classList.remove('dragging'));
        card.classList.add('dragging');
        state.selectedCard = state.cards.find(c => c.el === card);
        
        // æ˜¾ç¤ºé¢œè‰²é€‰æ‹©å™¨
        showColorPicker(card);
      });
      
      window.addEventListener('pointermove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        
        const newX = initialX + dx;
        const newY = initialY + dy;
        
        const bounds = container.getBoundingClientRect();
        const cardW = 110, cardH = 95;
        const padding = 10;
        
        // é™åˆ¶åœ¨å®¹å™¨å†…
        const boundedX = Math.max(padding, Math.min(bounds.width - cardW - padding, newX));
        const boundedY = Math.max(padding, Math.min(bounds.height - cardH - padding, newY));
        
        card.style.left = `${boundedX}px`;
        card.style.top = `${boundedY}px`;
        
        // æ›´æ–°çŠ¶æ€
        const cardState = state.cards.find(c => c.el === card);
        if (cardState) {
          cardState.x = boundedX;
          cardState.y = boundedY;
        }
        
        redrawConnections();
        
        // æ›´æ–°ä¸´æ—¶è¿çº¿
        if (state.connectingCard && state.sourceSide) {
          updateTempConnection(e.clientX, e.clientY);
        }
      });
      
      const stopDrag = () => {
        if (!isDragging) return;
        
        isDragging = false;
        state.isDragging = false;
        card.classList.remove('dragging');
      };
      
      window.addEventListener('pointerup', stopDrag);
      window.addEventListener('pointerleave', stopDrag);
    }

    function setupCardEdges(card) {
      const edges = card.querySelectorAll('.card-edge');
      edges.forEach(edge => {
        edge.addEventListener('pointerdown', (e) => {
          e.stopPropagation();
          
          if (state.deleteMode) return;
          
          const side = edge.dataset.side;
          
          if (state.connectMode) {
            if (!state.connectingCard) {
              // ç¬¬ä¸€ä¸ªå¡ç‰‡è¢«é€‰ä¸­
              state.connectingCard = state.cards.find(c => c.el === card);
              state.sourceSide = side;
              
              card.classList.add('source-card');
              
              // æ˜¾ç¤ºè¿æ¥ç±»å‹é€‰æ‹©å™¨
              showConnectionSelector();
              
              // åˆ›å»ºä¸´æ—¶è¿çº¿
              createTempConnection();
            } else {
              // ç¬¬äºŒä¸ªå¡ç‰‡è¢«é€‰ä¸­ï¼Œå®Œæˆè¿çº¿
              if (connectionSelector.classList.contains('active')) {
                // å¦‚æœé€‰æ‹©å™¨è¿˜æ‰“å¼€ï¼Œå…ˆç¡®è®¤
                confirmConnection();
              }
              
              const targetCard = state.cards.find(c => c.el === card);
              
              if (state.connectingCard.id !== targetCard.id) {
                // ç¡®å®šç›®æ ‡è¾¹ç¼˜
                const targetSide = determineTargetSide(state.connectingCard, targetCard, side);
                
                // åˆ›å»ºè¿æ¥
                createConnection(
                  state.connectingCard, 
                  targetCard, 
                  state.sourceSide, 
                  targetSide, 
                  state.lineType, 
                  state.arrowType
                );
              }
              
              // é‡ç½®çŠ¶æ€
              state.connectingCard.el.classList.remove('source-card');
              state.connectingCard = null;
              state.sourceSide = null;
              state.connectMode = false;
              
              // éšè—UI
              hideConnectionSelector();
              tempConnectionContainer.innerHTML = '';
              
              // æ›´æ–°æŒ‰é’®çŠ¶æ€
              document.getElementById('connectBtn').classList.remove('connect-mode');
              document.getElementById('connectBtn').textContent = 'åˆ›å»ºè¿çº¿';
              
              // æ¢å¤æç¤º
              instructions.innerHTML = `
                <span class="highlight-instruction">æ‹–æ‹½</span>å¡ç‰‡è°ƒæ•´ä½ç½® â€¢ 
                <span class="highlight-instruction">ç‚¹å‡»</span>å¡ç‰‡ä¿®æ”¹é¢œè‰² â€¢ 
                <span class="highlight-instruction">ç‚¹å‡»åº•éƒ¨æŒ‰é’®</span>åˆ›å»º/åˆ é™¤è¿çº¿
              `;
            }
          }
        });
      });
    }

    function determineTargetSide(sourceCard, targetCard, clickedSide) {
      // è®¡ç®—ä¸¤ä¸ªå¡ç‰‡ä¸­å¿ƒç‚¹
      const sourceCenter = {
        x: sourceCard.x + sourceCard.width / 2,
        y: sourceCard.y + sourceCard.height / 2
      };
      
      const targetCenter = {
        x: targetCard.x + targetCard.width / 2,
        y: targetCard.y + targetCard.height / 2
      };
      
      // è®¡ç®—æ–¹å‘å‘é‡
      const dx = targetCenter.x - sourceCenter.x;
      const dy = targetCenter.y - sourceCenter.y;
      
      // æ ¹æ®è§’åº¦ç¡®å®šæœ€ä½³ç›®æ ‡è¾¹ç¼˜
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;
      
      if (angle > -45 && angle <= 45) return 'left';     // å³
      if (angle > 45 && angle <= 135) return 'top';      // ä¸‹
      if (angle > 135 || angle <= -135) return 'right';  // å·¦
      return 'bottom';                                   // ä¸Š
    }

    function startConnectMode() {
      state.connectMode = true;
      document.getElementById('connectBtn').classList.add('connect-mode');
      document.getElementById('connectBtn').textContent = 'é€‰æ‹©æºå¡ç‰‡';
      
      // é«˜äº®æ‰€æœ‰å¡ç‰‡è¾¹ç¼˜
      state.cards.forEach(card => {
        const edges = card.el.querySelectorAll('.card-edge');
        edges.forEach(edge => {
          edge.style.background = 'rgba(16, 185, 129, 0.3)';
          edge.style.border = '1px solid #10b981';
        });
      });
      
      instructions.innerHTML = `
        <span class="highlight-instruction">ç‚¹å‡»æºå¡ç‰‡è¾¹ç¼˜</span>å¼€å§‹åˆ›å»ºè¿çº¿
      `;
    }

    function createTempConnection() {
      const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      tempSvg.setAttribute('width', '100%');
      tempSvg.setAttribute('height', '100%');
      
      const tempPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      tempPath.setAttribute('stroke', '#fbbf24');
      tempPath.setAttribute('stroke-width', '3');
      tempPath.setAttribute('stroke-dasharray', '5,5');
      tempPath.setAttribute('fill', 'none');
      tempPath.setAttribute('id', 'tempPath');
      
      // åˆ›å»ºç®­å¤´æ ‡è®°
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      
      if (state.arrowType !== 'none') {
        const endMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        endMarker.setAttribute('id', 'temp-arrow-end');
        endMarker.setAttribute('viewBox', '0 0 10 10');
        endMarker.setAttribute('refX', '9');
        endMarker.setAttribute('refY', '5');
        endMarker.setAttribute('markerWidth', '6');
        endMarker.setAttribute('markerHeight', '6');
        endMarker.setAttribute('orient', 'auto');
        
        const polyEnd = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        polyEnd.setAttribute('points', '0 0, 10 5, 0 10');
        polyEnd.setAttribute('fill', '#fbbf24');
        
        endMarker.appendChild(polyEnd);
        defs.appendChild(endMarker);
        
        if (state.arrowType === 'single') {
          tempPath.setAttribute('marker-end', 'url(#temp-arrow-end)');
        } else if (state.arrowType === 'double') {
          const startMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
          startMarker.setAttribute('id', 'temp-arrow-start');
          startMarker.setAttribute('viewBox', '0 0 10 10');
          startMarker.setAttribute('refX', '1');
          startMarker.setAttribute('refY', '5');
          startMarker.setAttribute('markerWidth', '6');
          startMarker.setAttribute('markerHeight', '6');
          startMarker.setAttribute('orient', 'auto');
          
          const polyStart = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
          polyStart.setAttribute('points', '10 0, 0 5, 10 10');
          polyStart.setAttribute('fill', '#fbbf24');
          
          startMarker.appendChild(polyStart);
          defs.appendChild(startMarker);
          tempPath.setAttribute('marker-start', 'url(#temp-arrow-start)');
          tempPath.setAttribute('marker-end', 'url(#temp-arrow-end)');
        }
      }
      
      tempSvg.appendChild(defs);
      tempSvg.appendChild(tempPath);
      tempConnectionContainer.innerHTML = '';
      tempConnectionContainer.appendChild(tempSvg);
    }

    function updateTempConnection(clientX, clientY) {
      if (!state.connectingCard || !state.sourceSide) return;
      
      const tempPath = document.getElementById('tempPath');
      if (!tempPath) return;
      
      // è·å–å®¹å™¨ä½ç½®
      const containerRect = container.getBoundingClientRect();
      
      // è®¡ç®—èµ·ç‚¹
      const p1 = getAnchorPoint(state.connectingCard, state.sourceSide);
      
      // è®¡ç®—ç»ˆç‚¹
      let p2;
      if (clientX && clientY) {
        // ä½¿ç”¨é¼ æ ‡ä½ç½®
        p2 = {
          x: clientX - containerRect.left,
          y: clientY - containerRect.top
        };
      } else {
        // ä½¿ç”¨å®¹å™¨ä¸­å¿ƒ
        p2 = {
          x: containerRect.width / 2,
          y: containerRect.height / 2
        };
      }
      
      // æ›´æ–°è·¯å¾„
      updatePath(tempPath, p1, p2, state.lineType, state.arrowType);
    }

    function createConnection(srcCard, tgtCard, srcAnchor, tgtAnchor, lineType, arrowType) {
      const id = `conn-${Date.now()}`;
      
      // åˆ›å»ºSVG
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      svg.style.position = 'absolute';
      svg.style.top = '0';
      svg.style.left = '0';
      svg.style.pointerEvents = 'none';
      
      // åˆ›å»ºç®­å¤´æ ‡è®°
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      
      if (arrowType !== 'none') {
        const endMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        endMarker.setAttribute('id', `arrow-end-${id}`);
        endMarker.setAttribute('viewBox', '0 0 10 10');
        endMarker.setAttribute('refX', '9');
        endMarker.setAttribute('refY', '5');
        endMarker.setAttribute('markerWidth', '6');
        endMarker.setAttribute('markerHeight', '6');
        endMarker.setAttribute('orient', 'auto');
        const polyEnd = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        polyEnd.setAttribute('points', '0 0, 10 5, 0 10');
        polyEnd.setAttribute('fill', '#60a5fa');
        endMarker.appendChild(polyEnd);
        defs.appendChild(endMarker);
      }
      
      if (arrowType === 'double') {
        const startMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        startMarker.setAttribute('id', `arrow-start-${id}`);
        startMarker.setAttribute('viewBox', '0 0 10 10');
        startMarker.setAttribute('refX', '1');
        startMarker.setAttribute('refY', '5');
        startMarker.setAttribute('markerWidth', '6');
        startMarker.setAttribute('markerHeight', '6');
        startMarker.setAttribute('orient', 'auto');
        const polyStart = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        polyStart.setAttribute('points', '10 0, 0 5, 10 10');
        polyStart.setAttribute('fill', '#60a5fa');
        startMarker.appendChild(polyStart);
        defs.appendChild(startMarker);
      }
      
      svg.appendChild(defs);
      
      // åˆ›å»ºè·¯å¾„
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('stroke', '#60a5fa');
      path.setAttribute('stroke-width', '2.5');
      path.setAttribute('fill', 'none');
      path.setAttribute('class', 'connection-path');
      path.dataset.connId = id;
      
      if (arrowType === 'single') {
        path.setAttribute('marker-end', `url(#arrow-end-${id})`);
      } else if (arrowType === 'double') {
        path.setAttribute('marker-end', `url(#arrow-end-${id})`);
        path.setAttribute('marker-start', `url(#arrow-start-${id})`);
      }
      
      svg.appendChild(path);
      connectionsContainer.appendChild(svg);
      
      // åˆ›å»ºæ ‡ç­¾
      const label = document.createElement('div');
      label.className = 'connection-label';
      label.innerText = 'å…³ç³»';
      label.dataset.connId = id;
      container.appendChild(label);
      
      const conn = {
        id,
        src: srcCard.id,
        tgt: tgtCard.id,
        srcAnchor,
        tgtAnchor,
        lineType,
        arrowType,
        svg,
        path,
        labelEl: label,
        label: 'å…³ç³»'
      };
      
      state.connections.push(conn);
      setupLabelEdit(label);
      setupPathDelete(path);
      updateConnection(conn);
    }

    function getAnchorPoint(card, anchor) {
      const x = card.x;
      const y = card.y;
      const w = card.width;
      const h = card.height;
      
      switch (anchor) {
        case 'top': return { x: x + w / 2, y: y };
        case 'right': return { x: x + w, y: y + h / 2 };
        case 'bottom': return { x: x + w / 2, y: y + h };
        case 'left': return { x: x, y: y + h / 2 };
        default: return { x: x + w / 2, y: y + h / 2 };
      }
    }

    function updatePath(path, p1, p2, lineType, arrowType) {
      let d;
      
      if (lineType === 'straight') {
        // ç›´çº¿
        d = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
      } else if (lineType === 'ortho') {
        // ç›´è§’æŠ˜çº¿ - æ™ºèƒ½é€‰æ‹©è½¬æŠ˜ç‚¹
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        
        let midX, midY;
        
        // é€‰æ‹©æœ€ä½³è½¬æŠ˜æ–¹å‘
        if (Math.abs(dx) > Math.abs(dy)) {
          // æ°´å¹³ä¸»å¯¼ - å…ˆæ°´å¹³ï¼Œå†å‚ç›´
          if (p1.x < p2.x) {
            midX = p2.x;
            midY = p1.y;
          } else {
            midX = p1.x;
            midY = p2.y;
          }
        } else {
          // å‚ç›´ä¸»å¯¼ - å…ˆå‚ç›´ï¼Œå†æ°´å¹³
          if (p1.y < p2.y) {
            midX = p1.x;
            midY = p2.y;
          } else {
            midX = p2.x;
            midY = p1.y;
          }
        }
        
        // ç¡®ä¿è½¬æŠ˜ç‚¹åœ¨åˆç†èŒƒå›´å†…
        midX = Math.max(0, Math.min(container.clientWidth, midX));
        midY = Math.max(0, Math.min(container.clientHeight, midY));
        
        d = `M ${p1.x} ${p1.y} L ${midX} ${midY} L ${p2.x} ${p2.y}`;
      }
      
      path.setAttribute('d', d);
    }

    function updateConnection(conn) {
      const src = state.cards.find(c => c.id === conn.src);
      const tgt = state.cards.find(c => c.id === conn.tgt);
      if (!src || !tgt) return;
      
      const p1 = getAnchorPoint(src, conn.srcAnchor);
      const p2 = getAnchorPoint(tgt, conn.tgtAnchor);
      
      updatePath(conn.path, p1, p2, conn.lineType, conn.arrowType);
      
      // æ›´æ–°æ ‡ç­¾ä½ç½®
      if (conn.lineType === 'straight') {
        conn.labelEl.style.left = `${(p1.x + p2.x) / 2}px`;
        conn.labelEl.style.top = `${(p1.y + p2.y) / 2}px`;
      } else if (conn.lineType === 'ortho') {
        // ç›´è§’æŠ˜çº¿ - æ ‡ç­¾æ”¾åœ¨ä¸­é—´ç‚¹
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        
        let midX, midY;
        
        if (Math.abs(dx) > Math.abs(dy)) {
          // æ°´å¹³ä¸»å¯¼
          midX = (p1.x + p2.x) / 2;
          midY = p1.y;
        } else {
          // å‚ç›´ä¸»å¯¼
          midX = p1.x;
          midY = (p1.y + p2.y) / 2;
        }
        
        conn.labelEl.style.left = `${midX}px`;
        conn.labelEl.style.top = `${midY}px`;
      }
    }

    function redrawConnections() {
      state.connections.forEach(updateConnection);
    }

    function setupLabelEdit(label) {
      label.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
        
        // åˆ é™¤æ¨¡å¼ä¸‹ä¸ç¼–è¾‘
        if (state.deleteMode) return;
        
        const input = document.createElement('input');
        input.value = label.innerText;
        input.style.cssText = `
          width: 80px; padding: 2px 5px; border: 1px solid #fbbf24;
          border-radius: 10px; background: rgba(30, 41, 59, 0.95);
          color: white; text-align: center; font-size: 0.8rem;
          outline: none; pointer-events: auto;
          font-family: -apple-system, BlinkMacSystemFont, 'PingFang SC', 'Microsoft YaHei', sans-serif;
        `;
        label.innerHTML = '';
        label.appendChild(input);
        input.focus();
        
        // é€‰æ‹©æ‰€æœ‰æ–‡æœ¬
        input.select();
        
        const save = () => {
          const text = input.value.trim() || 'å…³ç³»';
          label.innerHTML = text;
          const conn = state.connections.find(c => c.labelEl === label);
          if (conn) conn.label = text;
        };
        
        input.addEventListener('blur', save);
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            save();
            label.blur();
          }
        });
        
        // é˜²æ­¢å†’æ³¡
        input.addEventListener('pointerdown', (e) => e.stopPropagation());
      });
    }

    function setupPathDelete(path) {
      path.addEventListener('pointerdown', (e) => {
        if (state.deleteMode) {
          e.stopPropagation();
          const id = path.dataset.connId;
          deleteConnection(id);
        }
      });
    }

    function deleteConnection(id) {
      const conn = state.connections.find(c => c.id === id);
      if (conn) {
        conn.svg.remove();
        conn.labelEl.remove();
        state.connections = state.connections.filter(c => c.id !== id);
      }
    }

    function setupEventListeners() {
      document.getElementById('connectBtn').addEventListener('click', () => {
        if (state.connectMode) {
          cancelConnection();
        } else {
          startConnectMode();
        }
      });

      document.getElementById('deleteBtn').addEventListener('click', () => {
        state.deleteMode = !state.deleteMode;
        const btn = document.getElementById('deleteBtn');
        
        if (state.deleteMode) {
          btn.classList.add('delete-mode');
          btn.textContent = 'é€€å‡ºåˆ é™¤';
          
          // å–æ¶ˆè¿çº¿æ¨¡å¼
          if (state.connectMode) {
            cancelConnection();
          }
          
          // é«˜äº®æ‰€æœ‰è¿æ¥
          document.querySelectorAll('.connection-path').forEach(path => {
            path.style.stroke = '#f87171';
            path.style.strokeWidth = '3';
          });
          
          document.querySelectorAll('.connection-label').forEach(label => {
            label.style.borderColor = '#f87171';
            label.style.background = 'rgba(185, 28, 28, 0.8)';
          });
          
          // éšè—é¢œè‰²é€‰æ‹©å™¨
          hideColorPicker();
          
          instructions.innerHTML = `
            <span class="highlight-instruction">ç‚¹å‡»è¿çº¿æˆ–æ ‡ç­¾</span>åˆ é™¤å…³ç³»
          `;
        } else {
          btn.classList.remove('delete-mode');
          btn.textContent = 'åˆ é™¤è¿çº¿';
          
          // æ¢å¤è¿æ¥æ ·å¼
          document.querySelectorAll('.connection-path').forEach(path => {
            path.style.stroke = '#60a5fa';
            path.style.strokeWidth = '2.5';
          });
          
          document.querySelectorAll('.connection-label').forEach(label => {
            label.style.borderColor = '#60a5fa';
            label.style.background = 'rgba(15, 23, 42, 0.9)';
          });
          
          instructions.innerHTML = `
            <span class="highlight-instruction">æ‹–æ‹½</span>å¡ç‰‡è°ƒæ•´ä½ç½® â€¢ 
            <span class="highlight-instruction">ç‚¹å‡»</span>å¡ç‰‡ä¿®æ”¹é¢œè‰² â€¢ 
            <span class="highlight-instruction">ç‚¹å‡»åº•éƒ¨æŒ‰é’®</span>åˆ›å»º/åˆ é™¤è¿çº¿
          `;
        }
      });

      container.addEventListener('click', (e) => {
        if (!state.deleteMode) return;
        
        // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†æ ‡ç­¾
        const label = e.target.closest('.connection-label');
        if (label) {
          const id = label.dataset.connId;
          deleteConnection(id);
        }
      });

      // è·Ÿè¸ªé¼ æ ‡ä½ç½®ç”¨äºä¸´æ—¶è¿çº¿
      container.addEventListener('pointermove', (e) => {
        if (state.connectMode && state.connectingCard && state.sourceSide) {
          updateTempConnection(e.clientX, e.clientY);
        }
      });

      // å…³é—­å¼¹çª—å½“ç‚¹å‡»èƒŒæ™¯
      document.getElementById('exportModal').addEventListener('click', (e) => {
        if (e.target === document.getElementById('exportModal')) {
          document.getElementById('exportModal').style.display = 'none';
        }
      });

      document.getElementById('exportBtn').addEventListener('click', () => {
        document.getElementById('exportModal').style.display = 'flex';
      });

      document.getElementById('exportJpg').addEventListener('click', exportJPG);
      document.getElementById('exportXml').addEventListener('click', exportXML);

      window.addEventListener('resize', checkOrientation);
      
      // ç‚¹å‡»ç©ºç™½å¤„éšè—UI
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.card') && 
            !e.target.closest('.color-picker') && 
            !e.target.closest('.connection-label') &&
            !e.target.closest('.toolbar') &&
            !e.target.closest('.connection-selector')) {
          hideColorPicker();
          
          // å¦‚æœåœ¨è¿çº¿æ¨¡å¼ä¸”æ²¡æœ‰é€‰æ‹©æºå¡ç‰‡ï¼Œå–æ¶ˆè¿çº¿æ¨¡å¼
          if (state.connectMode && !state.connectingCard) {
            cancelConnection();
          }
        }
      });
      
      // å–æ¶ˆè¿çº¿æ¨¡å¼çš„å¿«æ·æ–¹å¼
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          if (connectionSelector.classList.contains('active')) {
            cancelConnection();
          } else if (state.connectMode) {
            cancelConnection();
          } else if (state.deleteMode) {
            state.deleteMode = false;
            document.getElementById('deleteBtn').classList.remove('delete-mode');
            document.getElementById('deleteBtn').textContent = 'åˆ é™¤è¿çº¿';
          }
        }
      });
      
      // ç‚¹å‡»é®ç½©å±‚å…³é—­é€‰æ‹©å™¨
      connectionSelector.addEventListener('click', (e) => {
        if (e.target === connectionSelector) {
          cancelConnection();
        }
      });
    }

    function initWatermark() {
      const now = new Date();
      const dateStr = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
      document.querySelector('.watermark').textContent = `ç”Ÿæˆäº ${dateStr} â€¢ é¡¹ç›®ç®¡ç†ä¹‹èˆŸ`;
    }

    function checkOrientation() {
      const alert = document.querySelector('.orientation-alert');
      const container = document.getElementById('container');
      
      if (window.innerHeight > window.innerWidth) {
        alert.style.display = 'flex';
        container.style.display = 'none';
        
        // ç¡®ä¿è¿çº¿æ¨¡å¼è¢«å–æ¶ˆ
        if (state.connectMode) cancelConnection();
        if (state.deleteMode) {
          state.deleteMode = false;
          document.getElementById('deleteBtn').classList.remove('delete-mode');
          document.getElementById('deleteBtn').textContent = 'åˆ é™¤è¿çº¿';
        }
        
        // å…³é—­é€‰æ‹©å™¨
        if (connectionSelector.classList.contains('active')) {
          hideConnectionSelector();
        }
      } else {
        alert.style.display = 'none';
        container.style.display = 'block';
        
        // é€‚é…æ¨ªå±å°ºå¯¸
        updateCardPositions();
      }
    }

    function updateCardPositions() {
      const w = container.clientWidth;
      const h = container.clientHeight;
      
      // ä¸º10ä¸ªå¡ç‰‡è§„åˆ’æœ€ä½³ä½ç½®
      const positions = getOptimalPositions(w, h);
      
      state.cards.forEach((card, i) => {
        if (i < positions.length) {
          card.x = positions[i].x;
          card.y = positions[i].y;
          card.el.style.left = `${card.x}px`;
          card.el.style.top = `${card.y}px`;
        }
      });
      
      redrawConnections();
      
      // æ›´æ–°ä¸´æ—¶è¿çº¿
      if (state.connectingCard && state.sourceSide) {
        updateTempConnection();
      }
    }

    function getOptimalPositions(width, height) {
      // ä¸ºiPhone 13 miniä¼˜åŒ–çš„ä½ç½®
      const cardW = 110, cardH = 95;
      const padding = 15;
      
      // è®¡ç®—æ¯è¡Œå¯æ”¾ç½®çš„å¡ç‰‡æ•°é‡
      const cardsPerRow = Math.floor((width - 2 * padding) / (cardW + padding));
      const rows = Math.ceil(10 / cardsPerRow);
      
      // è®¡ç®—èµ·å§‹ä½ç½®ä½¿å¡ç‰‡å±…ä¸­
      const totalWidth = cardsPerRow * cardW + (cardsPerRow - 1) * padding;
      const startX = (width - totalWidth) / 2;
      const totalHeight = rows * cardH + (rows - 1) * padding;
      const startY = (height - totalHeight) / 2;
      
      const positions = [];
      for (let i = 0; i < 10; i++) {
        const row = Math.floor(i / cardsPerRow);
        const col = i % cardsPerRow;
        const x = startX + col * (cardW + padding);
        const y = startY + row * (cardH + padding);
        
        // ç¡®ä¿åœ¨è¾¹ç•Œå†…
        positions.push({
          x: Math.max(padding, Math.min(width - cardW - padding, x)),
          y: Math.max(padding, Math.min(height - cardH - padding, y))
        });
      }
      
      return positions;
    }

    function showColorPicker(card) {
      if (!state.selectedCard) return;
      
      // æ¢å¤ä¸Šæ¬¡é€‰æ‹©çš„é¢œè‰²
      if (state.lastColorSelection[state.selectedCard.id] !== undefined) {
        const items = colorGrid.querySelectorAll('.color-item');
        items.forEach((item, index) => {
          item.classList.toggle('selected', index === state.lastColorSelection[state.selectedCard.id]);
        });
      }
      
      const rect = card.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();
      
      // åœ¨å¡ç‰‡ä¸Šæ–¹æ˜¾ç¤ºï¼Œé¿å…è¢«å·¥å…·æ é®æŒ¡
      let left = rect.left + rect.width / 2 - 110; // 220px/2 = 110px
      let top = rect.top - 60; // é¢œè‰²é€‰æ‹©å™¨é«˜åº¦çº¦50px + 10pxé—´è·
      
      // æ£€æŸ¥è¾¹ç•Œ
      if (left < containerRect.left + 5) left = containerRect.left + 5;
      if (left + 220 > containerRect.right - 5) left = containerRect.right - 225;
      if (top < containerRect.top + 5) top = rect.bottom + 5;
      
      colorPicker.style.left = `${left - containerRect.left}px`;
      colorPicker.style.top = `${top - containerRect.top}px`;
      colorPicker.style.display = 'block';
    }

    function hideColorPicker() {
      colorPicker.style.display = 'none';
    }

    // Export functions
    async function exportJPG() {
      document.getElementById('exportModal').style.display = 'none';
      const loading = document.getElementById('loading');
      loading.style.display = 'flex';

      try {
        // ä¸´æ—¶éšè—UIå…ƒç´ 
        const toolbar = document.querySelector('.toolbar');
        const cp = document.getElementById('colorPicker');
        const cs = document.getElementById('connectionSelector');
        const watermark = document.querySelector('.watermark');
        const instr = document.getElementById('instructions');
        
        const origTb = toolbar.style.display;
        const origCp = cp.style.display;
        const origCs = cs.style.display;
        const origInstrDisp = instr.style.display;
        
        toolbar.style.display = 'none';
        cp.style.display = 'none';
        cs.style.display = 'none';
        instr.style.display = 'none';
        
        // æ·»åŠ å¯¼å‡ºæ°´å°
        const exportWatermark = document.createElement('div');
        exportWatermark.className = 'watermark';
        exportWatermark.style.bottom = '5px';
        exportWatermark.style.right = '10px';
        exportWatermark.style.fontSize = '0.7rem';
        exportWatermark.textContent = `é¡¹ç›®ç®¡ç†ä¹‹èˆŸ â€¢ ${new Date().toLocaleDateString('zh-CN')}`;
        container.appendChild(exportWatermark);
        
        const canvas = await html2canvas(container, {
          backgroundColor: null,
          scale: 2,
          useCORS: true,
          allowTaint: true,
          logging: false
        });
        
        // æ¢å¤åŸå§‹çŠ¶æ€
        toolbar.style.display = origTb;
        cp.style.display = origCp;
        cs.style.display = origCs;
        instr.style.display = origInstrDisp;
        container.removeChild(exportWatermark);
        
        // åˆ›å»ºä¸‹è½½é“¾æ¥
        const link = document.createElement('a');
        link.download = `é¡¹ç›®ç®¡ç†ä¹‹èˆŸ_${new Date().toISOString().slice(0, 10)}.jpg`;
        link.href = canvas.toDataURL('image/jpeg', 0.92);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
      } catch (e) {
        alert('å¯¼å‡ºå›¾ç‰‡å¤±è´¥ï¼Œè¯·é‡è¯•');
        console.error(e);
      } finally {
        loading.style.display = 'none';
      }
    }

    function exportXML() {
      document.getElementById('exportModal').style.display = 'none';

      let xml = `<?xml version="1.0" encoding="UTF-8"?>\n<projectManagementBoat version="2.1">\n`;
      
      // å…ƒæ•°æ®
      xml += `  <metadata>\n`;
      xml += `    <created>${new Date().toISOString()}</created>\n`;
      xml += `    <device>${navigator.userAgent}</device>\n`;
      xml += `  </metadata>\n`;

      // Cards
      xml += `  <cards>\n`;
      state.cards.forEach(card => {
        const idx = parseInt(card.id.split('-')[1]);
        xml += `    <card id="${card.id}" x="${Math.round(card.x)}" y="${Math.round(card.y)}" color="${card.color}" textColor="${card.textColor}">\n`;
        xml += `      <title><![CDATA[${cards[idx].title}]]></title>\n`;
        xml += `      <subtitle><![CDATA[${cards[idx].sub}]]></subtitle>\n`;
        xml += `    </card>\n`;
      });
      xml += `  </cards>\n`;

      // Connections
      xml += `  <connections>\n`;
      state.connections.forEach(conn => {
        xml += `    <connection id="${conn.id}" source="${conn.src}" target="${conn.tgt}" `;
        xml += `srcAnchor="${conn.srcAnchor}" tgtAnchor="${conn.tgtAnchor}" lineType="${conn.lineType}" arrowType="${conn.arrowType}" `;
        xml += `label="${escapeXml(conn.label)}"/>\n`;
      });
      xml += `  </connections>\n`;

      xml += `</projectManagementBoat>`;

      const blob = new Blob([xml], { type: 'application/xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `é¡¹ç›®ç®¡ç†ä¹‹èˆŸ_${new Date().toISOString().slice(0, 10)}.xml`;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    }

    function escapeXml(str) {
      if (!str) return '';
      return str.replace(/[&<>"']/g, (c) => {
        switch (c) {
          case '&': return '&amp;';
          case '<': return '&lt;';
          case '>': return '&gt;';
          case '"': return '&quot;';
          case "'": return '&apos;';
          default: return c;
        }
      });
    }

    // Start
    document.addEventListener('DOMContentLoaded', () => {
      // ç¡®ä¿å®¹å™¨éšè—ç›´åˆ°æ£€æŸ¥æ–¹å‘
      document.getElementById('container').style.display = 'none';
      init();
    });
  </script>
</body>
</html>
