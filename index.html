<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#1e3a8a" />
  <meta name="description" content="é¡¹ç›®ç®¡ç†ä¹‹èˆŸ - ä¸“ä¸ºå°å±è®¾å¤‡ä¼˜åŒ–çš„é¡¹ç›®ç®¡ç†å¯è§†åŒ–å·¥å…·" />
  <title>é¡¹ç›®ç®¡ç†ä¹‹èˆŸ</title>

  <!-- PWA Manifest (å†…è”) -->
  <link rel="manifest" href="data:application/manifest+json;base64,ewogICJuYW1lIjogIueVmeaKpeWtpuivvyIsCiAgInNob3J0X25hbWUiOiAi55WZ5oql5a2m6K%2F%2FIiwKICAic3RhcnRfdXJsIjogIi4vIiwKICAiZGlzcGxheSI6ICJzdGFuZGFsb25lIiwKICAiYmFja2dyb3VuZF9jb2xvciI6ICIjMWUzYThhIiwKICAidGhlbWVfY29sb3IiOiAiIzFlM2E4YSIsCiAgImljb25zIjogWwogICAgewogICAgICAic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIj48cGF0aCBmaWxsPSIjMWUzYThhIiBkPSJNMCAwaDE5MnYxOTJIMHoiLz48dGV4dCB4PSI5NiIgeT0iOTYiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSI0MCIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiPuWVmeaKpeWtpuivvyAgPC90ZXh0Pjwvc3ZnPg==IiwKICAgICAgInNpemVzIjogIjE5MngxOTIiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIgogICAgfQogIF0KfQo=">

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'PingFang SC', 'Microsoft YaHei', sans-serif;
      background: linear-gradient(135deg, #0f172a, #1e3a8a);
      color: white;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      position: relative;
    }

    .orientation-alert {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      text-align: center;
      padding: 20px;
    }

    .orientation-alert h2 {
      font-size: 2rem;
      margin-bottom: 15px;
      color: #60a5fa;
    }

    .orientation-alert p {
      font-size: 1.2rem;
      color: #cbd5e1;
      max-width: 90%;
    }

    .container {
      position: relative;
      width: 100%;
      height: 100%;
      display: none;
      overflow: hidden;
    }

    .card {
      position: absolute;
      width: 110px;
      height: 95px;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 6px;
      text-align: center;
      cursor: grab;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
      border: 2px solid #60a5fa;
      transition: transform 0.2s, box-shadow 0.2s;
      z-index: 10;
      backface-visibility: hidden;
      will-change: transform;
    }

    .card.dragging {
      transform: scale(1.05);
      z-index: 20;
      box-shadow: 0 0 0 3px #fbbf24, 0 0 15px rgba(251, 191, 36, 0.6);
    }

    .card:active {
      cursor: grabbing;
    }

    .card-title {
      font-weight: bold;
      font-size: 0.95rem;
      line-height: 1.3;
      margin-bottom: 2px;
    }

    .card-sub {
      font-size: 0.75rem;
      line-height: 1.3;
    }

    .anchor-point {
      position: absolute;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: rgba(96, 165, 250, 0.6);
      border: 2px solid white;
      z-index: 15;
      pointer-events: auto;
      cursor: pointer;
      display: none;
    }

    .toolbar {
      position: absolute;
      bottom: 15px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      gap: 15px;
      z-index: 100;
      padding: 0 10px;
    }

    .btn {
      padding: 10px 18px;
      border-radius: 25px;
      border: none;
      font-weight: bold;
      font-size: 0.95rem;
      cursor: pointer;
      background: rgba(30, 58, 138, 0.92);
      color: white;
      border: 2px solid #60a5fa;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.35);
      min-width: 100px;
      touch-action: manipulation;
      transition: all 0.2s;
    }

    .btn:active {
      transform: scale(0.97);
    }

    .btn:hover {
      background: rgba(59, 130, 246, 0.95);
    }

    .btn.delete-mode {
      background: rgba(185, 28, 28, 0.95);
      border-color: #f87171;
    }

    .color-picker {
      position: absolute;
      background: rgba(15, 23, 42, 0.95);
      border: 2px solid #60a5fa;
      border-radius: 12px;
      padding: 12px 8px;
      display: none;
      z-index: 50;
      box-shadow: 0 5px 18px rgba(0, 0, 0, 0.5);
      min-width: 220px;
    }

    .color-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
    }

    .color-item {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid #60a5fa;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .color-item:hover, .color-item.selected {
      transform: scale(1.2);
      box-shadow: 0 0 0 3px white;
    }

    .connections-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }

    .connection-path {
      pointer-events: auto !important;
      cursor: pointer;
    }

    .connection-label {
      position: absolute;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid #60a5fa;
      border-radius: 14px;
      padding: 4px 10px;
      font-size: 0.8rem;
      transform: translate(-50%, -50%);
      pointer-events: auto;
      cursor: pointer;
      max-width: 120px;
      text-align: center;
      word-break: break-word;
      z-index: 6;
      touch-action: manipulation;
    }

    .connection-type-picker {
      position: absolute;
      background: rgba(15, 23, 42, 0.95);
      border: 2px solid #60a5fa;
      border-radius: 12px;
      padding: 10px;
      display: none;
      z-index: 50;
      box-shadow: 0 5px 18px rgba(0, 0, 0, 0.5);
      min-width: 180px;
      max-height: 300px;
      overflow-y: auto;
    }

    .type-option {
      padding: 8px 10px;
      color: white;
      cursor: pointer;
      border-radius: 8px;
      margin: 4px 0;
      font-size: 0.9rem;
      touch-action: manipulation;
    }

    .type-option:hover, .type-option.selected {
      background: rgba(59, 130, 246, 0.6);
    }

    .export-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.92);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 200;
      touch-action: none;
    }

    .modal-content {
      background: rgba(15, 23, 42, 0.97);
      border: 2px solid #60a5fa;
      border-radius: 18px;
      padding: 25px;
      width: 90%;
      max-width: 380px;
      text-align: center;
    }

    .modal-title {
      font-size: 1.4rem;
      margin-bottom: 15px;
      color: #60a5fa;
    }

    .export-options {
      display: flex;
      gap: 15px;
      margin: 15px 0;
      flex-wrap: wrap;
      justify-content: center;
    }

    .export-option {
      background: rgba(30, 58, 138, 0.8);
      border: 1px solid #60a5fa;
      border-radius: 12px;
      padding: 12px;
      width: 140px;
      cursor: pointer;
      transition: all 0.2s;
      touch-action: manipulation;
    }

    .export-option:hover, .export-option:active {
      background: rgba(59, 130, 246, 0.85);
      transform: translateY(-2px);
    }

    .loading {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.88);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 300;
      touch-action: none;
    }

    .spinner {
      width: 35px;
      height: 35px;
      border: 3px solid rgba(96, 165, 250, 0.3);
      border-top: 3px solid #60a5fa;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 12px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-text {
      font-size: 1.1rem;
      text-align: center;
      padding: 0 20px;
    }

    .status-bar-padding {
      height: env(safe-area-inset-top);
    }

    .watermark {
      position: absolute;
      bottom: 8px;
      right: 10px;
      font-size: 0.75rem;
      color: rgba(156, 163, 175, 0.8);
      z-index: 1;
    }

    @media (max-aspect-ratio: 13/9) {
      .orientation-alert {
        display: flex;
      }
    }

    /* ç¡®ä¿åœ¨ iOS å®‰å…¨åŒºåŸŸå†… */
    @supports (padding-top: env(safe-area-inset-top)) {
      body {
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
      }
      
      .toolbar {
        bottom: calc(15px + env(safe-area-inset-bottom));
      }
    }
  </style>
</head>
<body>
  <div class="orientation-alert">
    <h2>ğŸ“± è¯·æ¨ªå±ä½¿ç”¨</h2>
    <p>ä¸ºäº†è·å¾—æœ€ä½³ä½“éªŒï¼Œè¯·å°†æ‰‹æœºæ—‹è½¬è‡³æ¨ªå±æ¨¡å¼</p>
  </div>

  <div class="container" id="container">
    <div class="connections-container" id="connectionsContainer"></div>
    <!-- Cards will be inserted by JS -->

    <div class="toolbar">
      <button class="btn" id="deleteBtn">åˆ é™¤è¿çº¿</button>
      <button class="btn" id="exportBtn">å¯¼å‡ºç»“æœ</button>
    </div>

    <div class="color-picker" id="colorPicker">
      <div class="color-grid" id="colorGrid"></div>
    </div>

    <div class="connection-type-picker" id="typePicker">
      <div class="type-option" data-type="straight-none">â†’ ç›´çº¿ï¼ˆæ— ç®­å¤´ï¼‰</div>
      <div class="type-option" data-type="straight-single">â†’ ç›´çº¿ï¼ˆå•å‘ï¼‰</div>
      <div class="type-option" data-type="straight-double">â†” ç›´çº¿ï¼ˆåŒå‘ï¼‰</div>
      <div class="type-option" data-type="polyline-none">â†’ æŠ˜çº¿ï¼ˆæ— ç®­å¤´ï¼‰</div>
      <div class="type-option" data-type="polyline-single">â†’ æŠ˜çº¿ï¼ˆå•å‘ï¼‰</div>
      <div class="type-option" data-type="polyline-double">â†” æŠ˜çº¿ï¼ˆåŒå‘ï¼‰</div>
    </div>

    <div class="watermark">é¡¹ç›®ç®¡ç†ä¹‹èˆŸ v1.2</div>
  </div>

  <div class="export-modal" id="exportModal">
    <div class="modal-content">
      <div class="modal-title">å¯¼å‡ºé¡¹ç›®ç®¡ç†æ–¹æ¡ˆ</div>
      <p>è¯·é€‰æ‹©ä¿å­˜æ ¼å¼</p>
      <div class="export-options">
        <div class="export-option" id="exportJpg">
          <svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z" fill="#60a5fa"/>
          </svg>
          <div style="margin-top: 8px; font-weight: bold;">JPG å›¾ç‰‡</div>
        </div>
        <div class="export-option" id="exportXml">
          <svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z" fill="#60a5fa"/>
          </svg>
          <div style="margin-top: 8px; font-weight: bold;">XML æ•°æ®</div>
        </div>
      </div>
      <p style="font-size: 0.8rem; color: #94a3b8; margin-top: 12px;">
        æ–‡ä»¶å°†è‡ªåŠ¨ä¸‹è½½åˆ°æ‚¨çš„è®¾å¤‡
      </p>
    </div>
  </div>

  <div class="loading" id="loading">
    <div class="spinner"></div>
    <div class="loading-text">æ­£åœ¨ç”Ÿæˆå¯¼å‡ºæ–‡ä»¶<br>è¯·ç¨å€™...</div>
  </div>

  <!-- html2canvas for JPG export -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <script>
    // Card data
    const cards = [
      { title: "èŠ±å¤šé•¿æ—¶é—´åšï¼Ÿ", sub: "è¿›åº¦ç®¡ç†" },
      { title: "å¦‚ä½•å®ç°æ•´ä½“æœ€ä¼˜ï¼Ÿ", sub: "æ•´åˆç®¡ç†" },
      { title: "å¦‚ä½•æ‰æ»¡æ„ï¼Ÿ", sub: "ä»·å€¼ç®¡ç†" },
      { title: "è°æ¥åšï¼Ÿ", sub: "èµ„æºä¸é‡‡è´­ç®¡ç†" },
      { title: "æŒ‰ä»€ä¹ˆè´¨é‡åšï¼Ÿ", sub: "è´¨é‡ç®¡ç†" },
      { title: "åšä»€ä¹ˆï¼Ÿ", sub: "èŒƒå›´ç®¡ç†" },
      { title: "ä¸ºè°åšï¼Ÿ", sub: "å¹²ç³»äººç®¡ç†" },
      { title: "å¦‚ä½•åä½œï¼Ÿ", sub: "æ²Ÿé€šç®¡ç†" },
      { title: "ç”¨å¤šå°‘æˆæœ¬åšï¼Ÿ", sub: "æˆæœ¬ç®¡ç†" },
      { title: "æœ‰å“ªäº›äºº/è´¢/äº‹ä¼šå¢åŠ éš¾åº¦ï¼Ÿ", sub: "é£é™©ç®¡ç†" }
    ];

    // 6ç§æ˜¾è‘—åŒºåˆ†çš„é¢œè‰²
    const colors = [
      "#1e3a8a", // æ·±è“
      "#0d9488", // é’ç»¿
      "#c2410c", // æ©™çº¢
      "#7e22ce", // ç´«
      "#0ea5e9", // å¤©è“
      "#ca8a04"  // é‡‘é»„
    ];

    // State
    let state = {
      cards: [],
      connections: [],
      selectedCard: null,
      connectingCard: null,
      deleteMode: false,
      isDragging: false,
      dragOffset: { x: 0, y: 0 },
      tempConnection: null,
      anchorStart: null, // 'top' | 'right' | 'bottom' | 'left'
      anchorEnd: null,
      lastColorSelection: {}
    };

    const container = document.getElementById('container');
    const connectionsContainer = document.getElementById('connectionsContainer');
    const colorPicker = document.getElementById('colorPicker');
    const colorGrid = document.getElementById('colorGrid');
    const typePicker = document.getElementById('typePicker');

    // Init
    function init() {
      createCards();
      createColorPicker();
      setupEventListeners();
      checkOrientation();
      initWatermark();
      
      // æ·»åŠ è§¦æ‘¸åé¦ˆ
      document.body.addEventListener('touchstart', () => {}, { passive: true });
    }

    function createCards() {
      const w = container.clientWidth;
      const h = container.clientHeight;
      
      // iPhone 13 mini æ¨ªå±çº¦ 643x320pxï¼Œä¸º10ä¸ªå¡ç‰‡è§„åˆ’ä½ç½®
      const positions = [
        { x: 40, y: 40 },     { x: 180, y: 40 },    { x: 320, y: 40 },    { x: 460, y: 40 },    { x: 600, y: 40 },
        { x: 40, y: 180 },    { x: 180, y: 180 },   { x: 320, y: 180 },   { x: 460, y: 180 },   { x: 600, y: 180 }
      ];
      
      // ç¡®ä¿ä½ç½®åœ¨å±å¹•å†…
      const cardW = 110, cardH = 95;
      const padding = 15;
      
      cards.forEach((cardData, i) => {
        const card = document.createElement('div');
        card.className = 'card';
        card.dataset.id = `card-${i}`;
        
        // ä¸ºå‰6å¼ å¡ç‰‡åˆ†é…é¢„è®¾ä½ç½®ï¼Œå…¶ä½™éšæœº
        let x, y;
        if (i < positions.length) {
          x = positions[i].x;
          y = positions[i].y;
          
          // ç¡®ä¿å¡ç‰‡å®Œå…¨åœ¨å±å¹•å†…
          x = Math.max(padding, Math.min(w - cardW - padding, x));
          y = Math.max(padding, Math.min(h - cardH - padding, y));
        } else {
          x = padding + Math.random() * (w - 2 * padding - cardW);
          y = padding + Math.random() * (h - 2 * padding - cardH);
        }
        
        // ä¸ºæ¯å¼ å¡ç‰‡åˆ†é…åˆå§‹é¢œè‰²ï¼ˆå¾ªç¯ä½¿ç”¨6ç§é¢œè‰²ï¼‰
        const color = colors[i % colors.length];
        card.style.backgroundColor = color;
        
        // è®¡ç®—æ–‡å­—é¢œè‰²
        const textColor = getContrastTextColor(color);
        card.style.color = textColor;
        
        // åˆ›å»ºé”šç‚¹
        const anchors = ['top', 'right', 'bottom', 'left'];
        anchors.forEach(anchor => {
          const anchorEl = document.createElement('div');
          anchorEl.className = 'anchor-point';
          anchorEl.dataset.anchor = anchor;
          anchorEl.dataset.cardId = `card-${i}`;
          card.appendChild(anchorEl);
        });
        
        const title = document.createElement('div');
        title.className = 'card-title';
        title.innerText = cardData.title;
        title.style.color = textColor;
        
        const sub = document.createElement('div');
        sub.className = 'card-sub';
        sub.innerText = cardData.sub;
        sub.style.color = textColor;
        
        card.appendChild(title);
        card.appendChild(sub);
        
        card.style.left = `${x}px`;
        card.style.top = `${y}px`;
        
        container.appendChild(card);
        
        state.cards.push({
          id: `card-${i}`,
          el: card,
          x: x,
          y: y,
          color: color,
          textColor: textColor,
          width: cardW,
          height: cardH
        });
        
        makeDraggable(card);
        setupAnchorPoints(card);
      });
    }

    function getContrastTextColor(bgColor) {
      // å°†åå…­è¿›åˆ¶é¢œè‰²è½¬æ¢ä¸º RGB
      let r, g, b;
      if (bgColor.startsWith('#')) {
        const hex = bgColor.slice(1);
        if (hex.length === 3) {
          r = parseInt(hex[0] + hex[0], 16);
          g = parseInt(hex[1] + hex[1], 16);
          b = parseInt(hex[2] + hex[2], 16);
        } else {
          r = parseInt(hex.substring(0, 2), 16);
          g = parseInt(hex.substring(2, 4), 16);
          b = parseInt(hex.substring(4, 6), 16);
        }
      } else {
        // ç®€å•å¤„ç†ï¼Œå®é™…åº”ç”¨ä¸­åº”æ›´å®Œå–„
        return '#ffffff';
      }
      
      // è®¡ç®—äº®åº¦
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      
      // äº®åº¦é˜ˆå€¼ï¼Œ128ä¸ºä¸­é—´å€¼
      return brightness < 128 ? '#ffffff' : '#000000';
    }

    function createColorPicker() {
      colorGrid.innerHTML = '';
      
      colors.forEach((color, index) => {
        const item = document.createElement('div');
        item.className = 'color-item';
        item.style.backgroundColor = color;
        
        // è®¾ç½®è¾¹æ¡†é¢œè‰²ä¸ºå¯¹æ¯”è‰²
        const borderColor = getContrastTextColor(color);
        item.style.borderColor = borderColor;
        
        item.addEventListener('click', () => {
          if (state.selectedCard) {
            // æ›´æ–°å¡ç‰‡èƒŒæ™¯è‰²
            state.selectedCard.el.style.backgroundColor = color;
            state.selectedCard.color = color;
            
            // æ›´æ–°æ–‡å­—é¢œè‰²
            const newTextColor = getContrastTextColor(color);
            state.selectedCard.textColor = newTextColor;
            
            // æ›´æ–°å­å…ƒç´ é¢œè‰²
            const title = state.selectedCard.el.querySelector('.card-title');
            const sub = state.selectedCard.el.querySelector('.card-sub');
            if (title) title.style.color = newTextColor;
            if (sub) sub.style.color = newTextColor;
            
            // æ›´æ–°çŠ¶æ€
            state.lastColorSelection[state.selectedCard.id] = index;
            
            hideColorPicker();
          }
        });
        
        colorGrid.appendChild(item);
      });
    }

    function makeDraggable(card) {
      let isDragging = false;
      let startX, startY, initialX, initialY;
      
      card.addEventListener('pointerdown', (e) => {
        if (state.deleteMode) return;
        e.preventDefault();
        
        const rect = card.getBoundingClientRect();
        startX = e.clientX;
        startY = e.clientY;
        initialX = parseFloat(card.style.left);
        initialY = parseFloat(card.style.top);
        
        isDragging = true;
        state.isDragging = true;
        
        // é«˜äº®é€‰ä¸­
        state.cards.forEach(c => c.el.classList.remove('dragging'));
        card.classList.add('dragging');
        state.selectedCard = state.cards.find(c => c.el === card);
        
        // æ˜¾ç¤ºé¢œè‰²é€‰æ‹©å™¨
        showColorPicker(card);
      });
      
      window.addEventListener('pointermove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        
        const newX = initialX + dx;
        const newY = initialY + dy;
        
        const bounds = container.getBoundingClientRect();
        const cardW = 110, cardH = 95;
        const padding = 10;
        
        // é™åˆ¶åœ¨å®¹å™¨å†…
        const boundedX = Math.max(padding, Math.min(bounds.width - cardW - padding, newX));
        const boundedY = Math.max(padding, Math.min(bounds.height - cardH - padding, newY));
        
        card.style.left = `${boundedX}px`;
        card.style.top = `${boundedY}px`;
        
        // æ›´æ–°çŠ¶æ€
        const cardState = state.cards.find(c => c.el === card);
        if (cardState) {
          cardState.x = boundedX;
          cardState.y = boundedY;
        }
        
        redrawConnections();
      });
      
      const stopDrag = () => {
        if (!isDragging) return;
        
        isDragging = false;
        state.isDragging = false;
        card.classList.remove('dragging');
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯ç‚¹å‡»ï¼ˆéæ‹–åŠ¨ï¼‰
        const dx = Math.abs(parseFloat(card.style.left) - initialX);
        const dy = Math.abs(parseFloat(card.style.top) - initialY);
        
        if (dx < 5 && dy < 5 && !state.connectingCard) {
          // ç‚¹å‡»å¡ç‰‡è¾¹ç¼˜ï¼Œæ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†é”šç‚¹
          showAnchorPoints(card);
        }
      };
      
      window.addEventListener('pointerup', stopDrag);
      window.addEventListener('pointerleave', stopDrag);
    }

    function setupAnchorPoints(card) {
      const anchorPoints = card.querySelectorAll('.anchor-point');
      anchorPoints.forEach(anchor => {
        anchor.addEventListener('click', (e) => {
          e.stopPropagation();
          const anchorType = anchor.dataset.anchor;
          handleAnchorClick(card, anchorType);
        });
      });
    }

    function handleAnchorClick(card, anchor) {
      if (state.deleteMode) return;
      
      if (state.connectingCard) {
        if (state.connectingCard.id !== card.id) {
          // å®Œæˆè¿æ¥ï¼Œæ˜¾ç¤ºç±»å‹é€‰æ‹©å™¨
          showTypePicker(card, anchor);
        } else {
          // åŒä¸€å¼ å¡ç‰‡ï¼Œå–æ¶ˆ
          state.connectingCard.el.style.boxShadow = '0 3px 10px rgba(0,0,0,0.4)';
          state.connectingCard = null;
          state.anchorStart = null;
          hideAnchorPoints(state.connectingCard.el);
        }
      } else {
        // å¼€å§‹è¿æ¥
        state.connectingCard = state.cards.find(c => c.el === card);
        state.anchorStart = anchor;
        card.style.boxShadow = '0 0 0 3px #60a5fa, 0 0 15px rgba(96, 165, 250, 0.7)';
        showAnchorPoints(card, true); // é«˜äº®æ˜¾ç¤º
      }
    }

    function showAnchorPoints(card, highlight = false) {
      const anchors = card.querySelectorAll('.anchor-point');
      anchors.forEach(anchor => {
        anchor.style.display = 'block';
        if (highlight) {
          anchor.style.backgroundColor = '#fbbf24';
          anchor.style.borderColor = 'white';
        } else {
          anchor.style.backgroundColor = 'rgba(96, 165, 250, 0.6)';
          anchor.style.borderColor = 'white';
        }
      });
      
      // éšè—å…¶ä»–å¡ç‰‡çš„é”šç‚¹
      state.cards.forEach(c => {
        if (c.el !== card) {
          const otherAnchors = c.el.querySelectorAll('.anchor-point');
          otherAnchors.forEach(a => a.style.display = 'none');
        }
      });
    }

    function hideAnchorPoints(card) {
      if (!card) return;
      
      const anchors = card.querySelectorAll('.anchor-point');
      anchors.forEach(anchor => {
        anchor.style.display = 'none';
      });
    }

    function showColorPicker(card) {
      if (!state.selectedCard) return;
      
      // æ¢å¤ä¸Šæ¬¡é€‰æ‹©çš„é¢œè‰²
      if (state.lastColorSelection[state.selectedCard.id] !== undefined) {
        const items = colorGrid.querySelectorAll('.color-item');
        items.forEach((item, index) => {
          item.classList.toggle('selected', index === state.lastColorSelection[state.selectedCard.id]);
        });
      }
      
      const rect = card.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();
      
      // åœ¨å¡ç‰‡ä¸Šæ–¹æ˜¾ç¤ºï¼Œé¿å…è¢«å·¥å…·æ é®æŒ¡
      let left = rect.left + rect.width / 2 - 110; // 220px/2 = 110px
      let top = rect.top - 60; // é¢œè‰²é€‰æ‹©å™¨é«˜åº¦çº¦50px + 10pxé—´è·
      
      // æ£€æŸ¥è¾¹ç•Œ
      if (left < containerRect.left + 5) left = containerRect.left + 5;
      if (left + 220 > containerRect.right - 5) left = containerRect.right - 225;
      if (top < containerRect.top + 5) top = rect.bottom + 5;
      
      colorPicker.style.left = `${left - containerRect.left}px`;
      colorPicker.style.top = `${top - containerRect.top}px`;
      colorPicker.style.display = 'block';
    }

    function hideColorPicker() {
      colorPicker.style.display = 'none';
    }

    function showTypePicker(card, anchorEnd) {
      state.anchorEnd = anchorEnd;
      const rect = card.el.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();
      const picker = typePicker;
      
      let left = rect.left + rect.width / 2 - 90; // 180px/2 = 90px
      let top = rect.top - picker.offsetHeight - 10;
      
      if (top < containerRect.top + 5) top = rect.bottom + 10;
      
      // è¾¹ç•Œæ£€æµ‹
      if (left < containerRect.left + 5) left = containerRect.left + 5;
      if (left + 180 > containerRect.right - 5) left = containerRect.right - 185;
      
      picker.style.left = `${left - containerRect.left}px`;
      picker.style.top = `${top - containerRect.top}px`;
      picker.style.display = 'block';
      
      // é€‰æ‹©ç±»å‹
      const options = picker.querySelectorAll('.type-option');
      options.forEach(opt => {
        opt.onclick = () => {
          const type = opt.dataset.type;
          createConnection(state.connectingCard, card, state.anchorStart, anchorEnd, type);
          picker.style.display = 'none';
          state.connectingCard.el.style.boxShadow = '0 3px 10px rgba(0,0,0,0.4)';
          state.connectingCard = null;
          state.anchorStart = null;
          state.anchorEnd = null;
          hideAnchorPoints(state.connectingCard?.el);
        };
      });
    }

    function getAnchorPoint(card, anchor) {
      const x = card.x;
      const y = card.y;
      const w = card.width;
      const h = card.height;
      
      switch (anchor) {
        case 'top-left': return { x: x, y: y };
        case 'top': return { x: x + w / 2, y: y };
        case 'top-right': return { x: x + w, y: y };
        case 'right': return { x: x + w, y: y + h / 2 };
        case 'bottom-right': return { x: x + w, y: y + h };
        case 'bottom': return { x: x + w / 2, y: y + h };
        case 'bottom-left': return { x: x, y: y + h };
        case 'left': return { x: x, y: y + h / 2 };
        default: return { x: x + w / 2, y: y + h / 2 };
      }
    }

    function createConnection(srcCard, tgtCard, srcAnchor, tgtAnchor, type) {
      const id = `conn-${Date.now()}`;
      
      // åˆ›å»ºSVG
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      svg.style.position = 'absolute';
      svg.style.top = '0';
      svg.style.left = '0';
      svg.style.pointerEvents = 'none';
      
      // åˆ›å»ºç®­å¤´æ ‡è®°
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      
      if (type.includes('single') || type.includes('double')) {
        const endMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        endMarker.setAttribute('id', `arrow-end-${id}`);
        endMarker.setAttribute('viewBox', '0 0 10 10');
        endMarker.setAttribute('refX', '9');
        endMarker.setAttribute('refY', '5');
        endMarker.setAttribute('markerWidth', '6');
        endMarker.setAttribute('markerHeight', '6');
        endMarker.setAttribute('orient', 'auto');
        const polyEnd = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        polyEnd.setAttribute('points', '0 0, 10 5, 0 10');
        polyEnd.setAttribute('fill', '#60a5fa');
        endMarker.appendChild(polyEnd);
        defs.appendChild(endMarker);
      }
      
      if (type.includes('double')) {
        const startMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
        startMarker.setAttribute('id', `arrow-start-${id}`);
        startMarker.setAttribute('viewBox', '0 0 10 10');
        startMarker.setAttribute('refX', '1');
        startMarker.setAttribute('refY', '5');
        startMarker.setAttribute('markerWidth', '6');
        startMarker.setAttribute('markerHeight', '6');
        startMarker.setAttribute('orient', 'auto');
        const polyStart = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        polyStart.setAttribute('points', '10 0, 0 5, 10 10');
        polyStart.setAttribute('fill', '#60a5fa');
        startMarker.appendChild(polyStart);
        defs.appendChild(startMarker);
      }
      
      svg.appendChild(defs);
      
      // åˆ›å»ºè·¯å¾„
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('stroke', '#60a5fa');
      path.setAttribute('stroke-width', '2.5');
      path.setAttribute('fill', 'none');
      path.setAttribute('class', 'connection-path');
      path.dataset.connId = id;
      
      if (type.includes('single')) {
        path.setAttribute('marker-end', `url(#arrow-end-${id})`);
      } else if (type.includes('double')) {
        path.setAttribute('marker-end', `url(#arrow-end-${id})`);
        path.setAttribute('marker-start', `url(#arrow-start-${id})`);
      }
      
      svg.appendChild(path);
      connectionsContainer.appendChild(svg);
      
      // åˆ›å»ºæ ‡ç­¾
      const label = document.createElement('div');
      label.className = 'connection-label';
      label.innerText = 'å…³ç³»';
      label.dataset.connId = id;
      container.appendChild(label);
      
      const conn = {
        id,
        src: srcCard.id,
        tgt: tgtCard.id,
        srcAnchor,
        tgtAnchor,
        type,
        svg,
        path,
        labelEl: label,
        label: 'å…³ç³»'
      };
      
      state.connections.push(conn);
      setupLabelEdit(label);
      setupPathDelete(path);
      updateConnection(conn);
    }

    function updateConnection(conn) {
      const src = state.cards.find(c => c.id === conn.src);
      const tgt = state.cards.find(c => c.id === conn.tgt);
      if (!src || !tgt) return;
      
      const p1 = getAnchorPoint(src, conn.srcAnchor);
      const p2 = getAnchorPoint(tgt, conn.tgtAnchor);
      
      let d;
      if (conn.type.startsWith('straight')) {
        // ç›´çº¿
        d = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
        
        // æ ‡ç­¾æ”¾åœ¨ä¸­ç‚¹
        conn.labelEl.style.left = `${(p1.x + p2.x) / 2}px`;
        conn.labelEl.style.top = `${(p1.y + p2.y) / 2}px`;
      } else {
        // æŠ˜çº¿ï¼šè®¡ç®—ä¸­é—´ç‚¹
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        
        let midX, midY;
        if (Math.abs(dx) > Math.abs(dy)) {
          // æ°´å¹³ä¸»å¯¼
          midX = (p1.x + p2.x) / 2;
          midY = p1.y + dy / 3;
        } else {
          // å‚ç›´ä¸»å¯¼
          midX = p1.x + dx / 3;
          midY = (p1.y + p2.y) / 2;
        }
        
        d = `M ${p1.x} ${p1.y} L ${midX} ${midY} L ${p2.x} ${p2.y}`;
        
        // æ ‡ç­¾æ”¾åœ¨å¼¯æ›²ç‚¹
        conn.labelEl.style.left = `${midX}px`;
        conn.labelEl.style.top = `${midY}px`;
      }
      
      conn.path.setAttribute('d', d);
    }

    function redrawConnections() {
      state.connections.forEach(updateConnection);
    }

    function setupLabelEdit(label) {
      label.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
        
        // åˆ é™¤æ¨¡å¼ä¸‹ä¸ç¼–è¾‘
        if (state.deleteMode) return;
        
        const input = document.createElement('input');
        input.value = label.innerText;
        input.style.cssText = `
          width: 80px; padding: 2px 5px; border: 1px solid #fbbf24;
          border-radius: 10px; background: rgba(30, 41, 59, 0.95);
          color: white; text-align: center; font-size: 0.8rem;
          outline: none; pointer-events: auto;
          font-family: -apple-system, BlinkMacSystemFont, 'PingFang SC', 'Microsoft YaHei', sans-serif;
        `;
        label.innerHTML = '';
        label.appendChild(input);
        input.focus();
        
        // é€‰æ‹©æ‰€æœ‰æ–‡æœ¬
        input.select();
        
        const save = () => {
          const text = input.value.trim() || 'å…³ç³»';
          label.innerHTML = text;
          const conn = state.connections.find(c => c.labelEl === label);
          if (conn) conn.label = text;
        };
        
        input.addEventListener('blur', save);
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            save();
            label.blur();
          }
        });
        
        // é˜²æ­¢å†’æ³¡
        input.addEventListener('pointerdown', (e) => e.stopPropagation());
      });
    }

    function setupPathDelete(path) {
      path.addEventListener('pointerdown', (e) => {
        if (state.deleteMode) {
          e.stopPropagation();
          const id = path.dataset.connId;
          deleteConnection(id);
        }
      });
    }

    function deleteConnection(id) {
      const conn = state.connections.find(c => c.id === id);
      if (conn) {
        conn.svg.remove();
        conn.labelEl.remove();
        state.connections = state.connections.filter(c => c.id !== id);
      }
    }

    function setupEventListeners() {
      document.getElementById('deleteBtn').addEventListener('click', () => {
        state.deleteMode = !state.deleteMode;
        const btn = document.getElementById('deleteBtn');
        
        if (state.deleteMode) {
          btn.classList.add('delete-mode');
          btn.textContent = 'é€€å‡ºåˆ é™¤';
          
          // é«˜äº®æ‰€æœ‰è¿æ¥
          document.querySelectorAll('.connection-path').forEach(path => {
            path.style.stroke = '#f87171';
            path.style.strokeWidth = '3';
          });
          
          document.querySelectorAll('.connection-label').forEach(label => {
            label.style.borderColor = '#f87171';
            label.style.background = 'rgba(185, 28, 28, 0.8)';
          });
          
          // éšè—æ‰€æœ‰é”šç‚¹
          state.cards.forEach(card => hideAnchorPoints(card.el));
          
          // éšè—é¢œè‰²é€‰æ‹©å™¨
          hideColorPicker();
        } else {
          btn.classList.remove('delete-mode');
          btn.textContent = 'åˆ é™¤è¿çº¿';
          
          // æ¢å¤è¿æ¥æ ·å¼
          document.querySelectorAll('.connection-path').forEach(path => {
            path.style.stroke = '#60a5fa';
            path.style.strokeWidth = '2.5';
          });
          
          document.querySelectorAll('.connection-label').forEach(label => {
            label.style.borderColor = '#60a5fa';
            label.style.background = 'rgba(15, 23, 42, 0.9)';
          });
        }
      });

      container.addEventListener('click', (e) => {
        if (!state.deleteMode) return;
        
        // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†æ ‡ç­¾
        const label = e.target.closest('.connection-label');
        if (label) {
          const id = label.dataset.connId;
          deleteConnection(id);
        }
      });

      // å…³é—­å¼¹çª—å½“ç‚¹å‡»èƒŒæ™¯
      document.getElementById('exportModal').addEventListener('click', (e) => {
        if (e.target === document.getElementById('exportModal')) {
          document.getElementById('exportModal').style.display = 'none';
        }
      });

      document.getElementById('exportBtn').addEventListener('click', () => {
        document.getElementById('exportModal').style.display = 'flex';
      });

      document.getElementById('exportJpg').addEventListener('click', exportJPG);
      document.getElementById('exportXml').addEventListener('click', exportXML);

      window.addEventListener('resize', checkOrientation);
      
      // ç‚¹å‡»ç©ºç™½å¤„éšè—UI
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.card') && 
            !e.target.closest('.color-picker') && 
            !e.target.closest('.connection-label') &&
            !e.target.closest('.connection-type-picker') &&
            !e.target.closest('.toolbar')) {
          hideColorPicker();
          if (state.connectingCard) {
            state.connectingCard.el.style.boxShadow = '0 3px 10px rgba(0,0,0,0.4)';
            state.connectingCard = null;
            state.anchorStart = null;
          }
          state.cards.forEach(card => hideAnchorPoints(card.el));
        }
      });
    }

    function initWatermark() {
      const now = new Date();
      const dateStr = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
      document.querySelector('.watermark').textContent = `ç”Ÿæˆäº ${dateStr} â€¢ é¡¹ç›®ç®¡ç†ä¹‹èˆŸ`;
    }

    function checkOrientation() {
      const alert = document.querySelector('.orientation-alert');
      const container = document.getElementById('container');
      
      if (window.innerHeight > window.innerWidth) {
        alert.style.display = 'flex';
        container.style.display = 'none';
      } else {
        alert.style.display = 'none';
        container.style.display = 'block';
        
        // é€‚é…æ¨ªå±å°ºå¯¸
        updateCardPositions();
      }
    }

    function updateCardPositions() {
      const w = container.clientWidth;
      const h = container.clientHeight;
      
      // ä¸º10ä¸ªå¡ç‰‡è§„åˆ’æœ€ä½³ä½ç½®
      const positions = getOptimalPositions(w, h);
      
      state.cards.forEach((card, i) => {
        if (i < positions.length) {
          card.x = positions[i].x;
          card.y = positions[i].y;
          card.el.style.left = `${card.x}px`;
          card.el.style.top = `${card.y}px`;
        }
      });
      
      redrawConnections();
    }

    function getOptimalPositions(width, height) {
      // ä¸ºiPhone 13 miniä¼˜åŒ–çš„ä½ç½®
      const cardW = 110, cardH = 95;
      const padding = 15;
      
      // è®¡ç®—æ¯è¡Œå¯æ”¾ç½®çš„å¡ç‰‡æ•°é‡
      const cardsPerRow = Math.floor((width - 2 * padding) / (cardW + padding));
      const rows = Math.ceil(10 / cardsPerRow);
      
      // è®¡ç®—èµ·å§‹ä½ç½®ä½¿å¡ç‰‡å±…ä¸­
      const totalWidth = cardsPerRow * cardW + (cardsPerRow - 1) * padding;
      const startX = (width - totalWidth) / 2;
      const totalHeight = rows * cardH + (rows - 1) * padding;
      const startY = (height - totalHeight) / 2;
      
      const positions = [];
      for (let i = 0; i < 10; i++) {
        const row = Math.floor(i / cardsPerRow);
        const col = i % cardsPerRow;
        const x = startX + col * (cardW + padding);
        const y = startY + row * (cardH + padding);
        
        // ç¡®ä¿åœ¨è¾¹ç•Œå†…
        positions.push({
          x: Math.max(padding, Math.min(width - cardW - padding, x)),
          y: Math.max(padding, Math.min(height - cardH - padding, y))
        });
      }
      
      return positions;
    }

    // Export functions
    async function exportJPG() {
      document.getElementById('exportModal').style.display = 'none';
      const loading = document.getElementById('loading');
      loading.style.display = 'flex';

      try {
        // ä¸´æ—¶éšè—UIå…ƒç´ 
        const toolbar = document.querySelector('.toolbar');
        const cp = document.getElementById('colorPicker');
        const tp = document.getElementById('typePicker');
        const watermark = document.querySelector('.watermark');
        
        const origTb = toolbar.style.display;
        const origCp = cp.style.display;
        const origTp = tp.style.display;
        const origWm = watermark.style.display;
        
        toolbar.style.display = 'none';
        cp.style.display = 'none';
        tp.style.display = 'none';
        
        // æ·»åŠ å¯¼å‡ºæ°´å°
        const exportWatermark = document.createElement('div');
        exportWatermark.className = 'watermark';
        exportWatermark.style.bottom = '5px';
        exportWatermark.style.right = '10px';
        exportWatermark.style.fontSize = '0.7rem';
        exportWatermark.textContent = `é¡¹ç›®ç®¡ç†ä¹‹èˆŸ â€¢ ${new Date().toLocaleDateString('zh-CN')}`;
        container.appendChild(exportWatermark);
        
        const canvas = await html2canvas(container, {
          backgroundColor: null,
          scale: 2,
          useCORS: true,
          allowTaint: true,
          logging: false
        });
        
        // æ¢å¤åŸå§‹çŠ¶æ€
        toolbar.style.display = origTb;
        cp.style.display = origCp;
        tp.style.display = origTp;
        watermark.style.display = origWm;
        container.removeChild(exportWatermark);
        
        // åˆ›å»ºä¸‹è½½é“¾æ¥
        const link = document.createElement('a');
        link.download = `é¡¹ç›®ç®¡ç†ä¹‹èˆŸ_${new Date().toISOString().slice(0, 10)}.jpg`;
        link.href = canvas.toDataURL('image/jpeg', 0.92);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
      } catch (e) {
        alert('å¯¼å‡ºå›¾ç‰‡å¤±è´¥ï¼Œè¯·é‡è¯•');
        console.error(e);
      } finally {
        loading.style.display = 'none';
      }
    }

    function exportXML() {
      document.getElementById('exportModal').style.display = 'none';

      let xml = `<?xml version="1.0" encoding="UTF-8"?>\n<projectManagementBoat version="1.2">\n`;
      
      // å…ƒæ•°æ®
      xml += `  <metadata>\n`;
      xml += `    <created>${new Date().toISOString()}</created>\n`;
      xml += `    <device>${navigator.userAgent}</device>\n`;
      xml += `  </metadata>\n`;

      // Cards
      xml += `  <cards>\n`;
      state.cards.forEach(card => {
        const idx = parseInt(card.id.split('-')[1]);
        xml += `    <card id="${card.id}" x="${Math.round(card.x)}" y="${Math.round(card.y)}" color="${card.color}" textColor="${card.textColor}">\n`;
        xml += `      <title><![CDATA[${cards[idx].title}]]></title>\n`;
        xml += `      <subtitle><![CDATA[${cards[idx].sub}]]></subtitle>\n`;
        xml += `    </card>\n`;
      });
      xml += `  </cards>\n`;

      // Connections
      xml += `  <connections>\n`;
      state.connections.forEach(conn => {
        xml += `    <connection id="${conn.id}" source="${conn.src}" target="${conn.tgt}" `;
        xml += `srcAnchor="${conn.srcAnchor}" tgtAnchor="${conn.tgtAnchor}" type="${conn.type}" `;
        xml += `label="${escapeXml(conn.label)}"/>\n`;
      });
      xml += `  </connections>\n`;

      xml += `</projectManagementBoat>`;

      const blob = new Blob([xml], { type: 'application/xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `é¡¹ç›®ç®¡ç†ä¹‹èˆŸ_${new Date().toISOString().slice(0, 10)}.xml`;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    }

    function escapeXml(str) {
      if (!str) return '';
      return str.replace(/[&<>"']/g, (c) => {
        switch (c) {
          case '&': return '&amp;';
          case '<': return '&lt;';
          case '>': return '&gt;';
          case '"': return '&quot;';
          case "'": return '&apos;';
          default: return c;
        }
      });
    }

    // Start
    document.addEventListener('DOMContentLoaded', () => {
      // ç¡®ä¿å®¹å™¨éšè—ç›´åˆ°æ£€æŸ¥æ–¹å‘
      document.getElementById('container').style.display = 'none';
      init();
    });
  </script>
</body>
</html>
